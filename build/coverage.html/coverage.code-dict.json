{"/home/travis/build/npmtest/node-npmtest-gh/test.js":"/* istanbul instrument in package npmtest_gh */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-gh/lib.npmtest_gh.js":"/* istanbul instrument in package npmtest_gh */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_gh = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_gh = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-gh/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-gh && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_gh */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_gh\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_gh.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_gh.rollup.js'] =\n            local.assetsDict['/assets.npmtest_gh.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_gh.__dirname + '/lib.npmtest_gh.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-gh/node_modules/gh/bin/gh.js":"#!/usr/bin/env node\n\n/*\n * Copyright 2013-2015, All Rights Reserved.\n *\n * Code licensed under the BSD License:\n * https://github.com/node-gh/gh/blob/master/LICENSE.md\n *\n * @author Eduardo Lundgren <edu@rdo.io>\n */\n\n'use strict';\n\nvar verbose = process.argv.indexOf('--verbose') !== -1;\nvar insane = process.argv.indexOf('--insane') !== -1;\n\nif (verbose || insane) {\n    process.env.GH_VERBOSE = true;\n}\n\nif (insane) {\n    process.env.GH_VERBOSE_INSANE = true;\n}\n\nrequire('../lib/cmd.js').run();\n","/home/travis/build/npmtest/node-npmtest-gh/node_modules/gh/lib/cmd.js":"/*\n * Copyright 2013-2015, All Rights Reserved.\n *\n * Code licensed under the BSD License:\n * https://github.com/node-gh/gh/blob/master/LICENSE.md\n *\n * @author Eduardo Lundgren <edu@rdo.io>\n */\n\n'use strict';\n\n// -- Requires -------------------------------------------------------------------------------------\n\nrequire('babel-polyfill');\n\nvar async = require('async'),\n    base = require('./base'),\n    configs = require('./configs'),\n    fs = require('fs'),\n    git = require('./git'),\n    logger = require('./logger'),\n    nopt = require('nopt'),\n    path = require('path'),\n    tracker = require('./tracker'),\n    User = require('./cmds/user').Impl,\n    config = configs.getConfig();\n\n// -- Utils ----------------------------------------------------------------------------------------\n\nfunction hasCommandInOptions(commands, options) {\n    if (commands) {\n        return commands.some(function (c) {\n            return options[c] !== undefined;\n        });\n    }\n\n    return false;\n}\n\n\nfunction invokePayload(options, command, cooked, remain) {\n    var payload;\n\n    if (command.DETAILS.payload && !hasCommandInOptions(command.DETAILS.commands, options)) {\n        payload = remain.concat();\n        payload.shift();\n        command.DETAILS.payload(payload, options);\n    }\n}\n\nfunction findCommand(name) {\n    var Command,\n        commandDir,\n        commandFiles,\n        commandPath;\n\n    commandDir = path.join(__dirname, 'cmds');\n    commandPath = path.join(commandDir, name + '.js');\n\n    if (fs.existsSync(commandPath)) {\n        Command = require(commandPath).Impl;\n    }\n    else {\n        commandFiles = base.find(commandDir, /\\.js$/i);\n        commandFiles.every(function (file) {\n            commandPath = path.join(commandDir, file);\n            Command = require(commandPath).Impl;\n\n            if (Command.DETAILS.alias === name) {\n                return false;\n            }\n\n            Command = null;\n            return true;\n        });\n    }\n\n    return Command;\n}\n\nfunction loadCommand(name) {\n    var Command = findCommand(name),\n        plugin;\n\n    // If command was not found, check if it is registered as a plugin.\n    if (!Command) {\n        try {\n            plugin = configs.getPlugin(name);\n        }\n        catch(e) {\n            return null;\n        }\n\n        Command = plugin.Impl;\n\n        // If plugin command exists, register the executed plugin name on\n        // process.env. This may simplify core plugin infrastructure.\n        process.env.NODEGH_PLUGIN = name;\n    }\n\n    return Command;\n}\n\nexports.setUp = function () {\n    var Command,\n        iterative,\n        operations = [],\n        options,\n        parsed = nopt(process.argv),\n        remain = parsed.argv.remain,\n        cooked = parsed.argv.cooked;\n\n    operations.push(function (callback) {\n        base.checkVersion();\n\n        if (tracker.optOut !== undefined) {\n            callback();\n            return;\n        }\n\n        tracker.askPermission(null, function () {\n            callback();\n        });\n    });\n\n    operations.push(function (callback) {\n        var module = remain[0];\n\n        if (cooked[0] === '--version' || cooked[0] === '-v') {\n            module = 'version';\n        }\n        else if (!remain.length ||\n            (cooked.indexOf('-h') >= 0) ||\n            (cooked.indexOf('--help') >= 0)) {\n            module = 'help';\n        }\n\n        Command = loadCommand(module);\n\n        if (!Command) {\n            tracker.trackCommand(remain);\n            logger.error('Command not found');\n            return;\n        }\n\n        options = nopt(\n            Command.DETAILS.options,\n            Command.DETAILS.shorthands, process.argv, 2);\n\n        iterative = Command.DETAILS.iterative;\n\n        cooked = options.argv.cooked;\n        remain = options.argv.remain;\n\n        options.number = options.number || [remain[1]];\n        options.remote = options.remote || config.default_remote;\n\n        if (module === 'help') {\n            callback();\n        }\n        else {\n            User.login(callback);\n        }\n    });\n\n    async.series(operations, function () {\n        var iterativeValues,\n            remoteUrl = git.getRemoteUrl(options.remote);\n\n        options.isTTY = {};\n        options.isTTY.in = Boolean(process.stdin.isTTY);\n        options.isTTY.out = Boolean(process.stdout.isTTY);\n        options.loggedUser = base.getUser();\n        options.remoteUser = git.getUserFromRemoteUrl(remoteUrl);\n\n        if (!options.user) {\n            if (options.repo || options.all) {\n                options.user = options.loggedUser;\n            }\n            else {\n                options.user = options.remoteUser || options.loggedUser;\n            }\n        }\n\n        options.repo = options.repo || git.getRepoFromRemoteURL(remoteUrl);\n        options.currentBranch = options.currentBranch || git.getCurrentBranch();\n\n        base.expandAliases(options);\n        options.github_host = config.github_host;\n        options.github_gist_host = config.github_gist_host;\n\n        // Try to retrieve iterative values from iterative option key,\n        // e.g. option['number'] === [1,2,3]. If iterative option key is not\n        // present, assume [undefined] in order to initialize the loop.\n        iterativeValues = options[iterative] || [undefined];\n\n        iterativeValues.forEach(function (value) {\n            options = base.clone(options);\n\n            // Value can be undefined when the command doesn't have a iterative\n            // option.\n            options[iterative] = value;\n\n            invokePayload(options, Command, cooked, remain);\n\n            new Command(options).run();\n\n            tracker.trackCommand(options.argv.original, Command.DETAILS);\n        });\n    });\n};\n\nexports.run = function () {\n    if (!fs.existsSync(configs.getUserHomePath())) {\n        configs.createGlobalConfig();\n    }\n\n    base.load();\n    configs.getConfig();\n\n    // If configs.PLUGINS_PATH_KEY is undefined, try to cache it before proceeding.\n    if (configs.getConfig()[configs.PLUGINS_PATH_KEY] === undefined) {\n        configs.getNodeModulesGlobalPath();\n    }\n\n    try {\n        process.env.GH_PATH = path.join(__dirname, '../');\n\n        this.setUp();\n    } catch (e) {\n        tracker.track('error');\n        console.error(e.stack || e);\n    }\n\n};\n","/home/travis/build/npmtest/node-npmtest-gh/node_modules/gh/lib/base.js":"/*\n * Copyright 2013-2015, All Rights Reserved.\n *\n * Code licensed under the BSD License:\n * https://github.com/node-gh/gh/blob/master/LICENSE.md\n *\n * @author Eduardo Lundgren <edu@rdo.io>\n */\n\n'use strict';\n\nvar configs = require('./configs'),\n    fs = require('fs'),\n    Github = require('github'),\n    path = require('path'),\n    tracker = require('./tracker'),\n    updateNotifier = require('update-notifier');\n\n// -- Config -------------------------------------------------------------------\n\nexports.clone = function (o) {\n    return JSON.parse(JSON.stringify(o));\n};\n\n// -- Utils --------------------------------------------------------------------\n\nexports.load = function () {\n    var config = configs.getConfig();\n\n    exports.github = new Github({\n        debug: false,\n        host: config.api.host,\n        protocol: config.api.protocol,\n        version: config.api.version,\n        pathPrefix: config.api.pathPrefix\n    });\n};\n\nexports.asyncReadPackages = function (callback) {\n    function async(err, data) {\n        if (err) {\n            throw err;\n        }\n\n        callback(JSON.parse(data));\n    }\n\n    fs.readFile(path.join(__dirname, '..', 'package.json'), async);\n\n    configs.getPlugins().forEach(function (plugin) {\n        fs.readFile(path.join(\n            configs.getNodeModulesGlobalPath(), plugin, 'package.json'), async);\n    });\n};\n\nexports.notifyVersion = function (pkg) {\n    var notifier = updateNotifier({pkg: pkg}),\n        update,\n        track = 'notify/';\n\n    if (notifier.update) {\n        update = notifier.update;\n\n        track += update.name + '/' + update.latest + '/from/' + update.current;\n\n        tracker.track(track);\n\n        notifier.notify();\n    }\n};\n\nexports.checkVersion = function () {\n    exports.asyncReadPackages(exports.notifyVersion);\n};\n\nexports.expandAliases = function (options) {\n    var config = configs.getConfig();\n\n    if (config.alias) {\n        options.fwd = config.alias[options.fwd] || options.fwd;\n        options.submit = config.alias[options.submit] || options.submit;\n        options.user = config.alias[options.user] || options.user;\n    }\n};\n\nexports.find = function (filepath, opt_pattern) {\n    return fs.readdirSync(filepath).filter(function (file) {\n        return (opt_pattern || /.*/).test(file);\n    });\n};\n\nexports.getUser = function () {\n    return configs.getConfig().github_user;\n};\n\n// Export some config methods to allow plugins to access them\nexports.getConfig = configs.getConfig;\nexports.writeGlobalConfig = configs.writeGlobalConfig;\n","/home/travis/build/npmtest/node-npmtest-gh/node_modules/gh/lib/configs.js":"/*\n * Copyright 2013-2015, All Rights Reserved.\n *\n * Code licensed under the BSD License:\n * https://github.com/node-gh/gh/blob/master/LICENSE.md\n *\n * @author Eduardo Lundgren <edu@rdo.io>\n */\n\n'use strict';\n\nvar fs = require('fs'),\n    logger = require('./logger'),\n    exec = require('./exec'),\n    path = require('path'),\n    userhome = require('userhome'),\n    which = require('which'),\n    cache = {},\n    plugins,\n    PLUGINS_PATH_KEY = 'plugins_path';\n\n// -- Config -------------------------------------------------------------------\n\nexports.getNodeModulesGlobalPath = function () {\n    var result,\n        path = exports.getConfig()[PLUGINS_PATH_KEY];\n\n    if (path === undefined) {\n        result = exec.spawnSync('npm', ['root', '-g']);\n\n        if (result.stdout) {\n            path = result.stdout;\n            exports.writeGlobalConfig(PLUGINS_PATH_KEY, path);\n        }\n        else {\n            logger.warn('Can\\'t resolve plugins directory path.');\n        }\n    }\n\n    return path;\n};\n\nexports.getUserHomePath = function () {\n    return userhome('.gh.json');\n};\n\nfunction getConfig(opt_plugin) {\n    var globalConfig = exports.getGlobalConfig(opt_plugin),\n        projectConfig,\n        result = {};\n\n    try {\n        projectConfig = JSON.parse(fs.readFileSync(exports.getProjectConfigPath()));\n\n        Object.keys(globalConfig).forEach(function (key) {\n            result[key] = globalConfig[key];\n        });\n\n        Object.keys(projectConfig).forEach(function (key) {\n            result[key] = projectConfig[key];\n        });\n\n        return result;\n    }\n    catch (e) {\n        logger.debug(e.message);\n\n        if (e.code !== 'MODULE_NOT_FOUND' && e.code !== 'ENOENT') {\n            throw e;\n        }\n\n        return globalConfig;\n    }\n}\n\nexports.getConfig = function (opt_plugin) {\n    var config = cache[opt_plugin];\n\n    if (!config) {\n        config = getConfig(opt_plugin);\n        cache[opt_plugin] = config;\n    }\n\n    var protocol = config.api.protocol + '://',\n        is_enterprise = (config.api.host !== 'api.github.com');\n\n    if (config.github_host === undefined) {\n        config.github_host = protocol + (is_enterprise ? config.api.host : 'github.com') + '/';\n    }\n    if (config.github_gist_host === undefined) {\n        config.github_gist_host = protocol + (is_enterprise ? config.api.host + '/gist' : 'gist.github.com') + '/';\n    }\n\n    return config;\n};\n\nexports.getGlobalConfig = function (opt_plugin) {\n    var config,\n        configPath,\n        userConfig;\n\n    configPath = exports.getUserHomePath();\n\n    if (!fs.existsSync(configPath)) {\n        exports.createGlobalConfig();\n    }\n\n    config = JSON.parse(fs.readFileSync(exports.getGlobalConfigPath()));\n    userConfig = JSON.parse(fs.readFileSync(configPath));\n\n    Object.keys(userConfig).forEach(function (key) {\n        config[key] = userConfig[key];\n    });\n\n    if (opt_plugin) {\n        exports.getPlugins().forEach(function (plugin) {\n            exports.addPluginConfig(config, plugin);\n        });\n    }\n\n    return config;\n};\n\nexports.getGlobalConfigPath = function () {\n    return path.join(__dirname, '../', 'default.gh.json');\n};\n\nexports.getProjectConfigPath = function () {\n    return path.join(process.cwd(), '.gh.json');\n};\n\nexports.removeGlobalConfig = function (key) {\n    var config = exports.getGlobalConfig();\n\n    delete config[key];\n\n    exports.saveJsonConfig(exports.getUserHomePath(), config);\n    cache = {};\n};\n\nexports.createGlobalConfig = function () {\n    exports.saveJsonConfig(exports.getUserHomePath(),\n        JSON.parse(fs.readFileSync(exports.getGlobalConfigPath()))\n    );\n    cache = {};\n};\n\nexports.writeGlobalConfig = function (jsonPath, value) {\n    var config = exports.getGlobalConfig(),\n        i,\n        output,\n        path,\n        pathLen;\n\n    path = jsonPath.split('.');\n    output = config;\n\n    for (i = 0, pathLen = path.length; i < pathLen; i++) {\n        output[path[i]] = config[path[i]] || (i + 1 === pathLen ? value : {});\n        output = output[path[i]];\n    }\n\n    exports.saveJsonConfig(exports.getUserHomePath(), config);\n    cache = {};\n};\n\nexports.saveJsonConfig = function (path, object) {\n    var options = {\n        mode: parseInt('0600', 8)\n    };\n\n    fs.writeFileSync(path, JSON.stringify(object, null, 4), options);\n};\n\nexports.writeGlobalConfigCredentials = function (user, token) {\n    var configPath = exports.getUserHomePath();\n\n    exports.writeGlobalConfig('github_user', user);\n    exports.writeGlobalConfig('github_token', token);\n    logger.log('Writing GH config data: ' + configPath);\n};\n\n// -- Plugins ------------------------------------------------------------------\n\nexports.addPluginConfig = function (config, plugin) {\n    var pluginConfig,\n        userConfig;\n\n    try {\n        // Always use the plugin name without prefix. To be safe removing \"gh-\"\n        // prefix from passed plugin.\n        plugin = exports.getPluginBasename(plugin || process.env.NODEGH_PLUGIN);\n\n        pluginConfig = require(path.join(\n            exports.getNodeModulesGlobalPath(), 'gh-' + plugin, 'gh-plugin.json'));\n\n        // Merge default plugin configuration with the user's.\n        userConfig = config.plugins[plugin] || {};\n\n        Object.keys(userConfig).forEach(function (key) {\n            pluginConfig[key] = userConfig[key];\n        });\n\n        config.plugins[plugin] = pluginConfig;\n    }\n    catch (e) {\n        if (e.code !== 'MODULE_NOT_FOUND') {\n            throw e;\n        }\n    }\n};\n\nfunction getPlugins() {\n    var pluginsPath = exports.getNodeModulesGlobalPath();\n\n    if (pluginsPath === '') {\n        return [];\n    }\n\n    try {\n        plugins = fs.readdirSync(pluginsPath).filter(function (plugin) {\n            return plugin.substring(0, 3) === 'gh-';\n        });\n    }\n    catch(e) {\n        plugins = [];\n        logger.warn('Can\\'t read plugins directory.');\n    }\n    finally {\n        return plugins;\n    }\n}\n\nexports.getPlugins = function () {\n    if (!plugins) {\n        plugins = getPlugins();\n    }\n\n    return plugins;\n};\n\nexports.getPlugin = function (plugin) {\n    plugin = exports.getPluginBasename(plugin);\n\n    return require(exports.getPluginPath('gh-' + plugin));\n};\n\nexports.getPluginPath = function (plugin) {\n    return fs.realpathSync(which.sync(plugin));\n};\n\nexports.getPluginBasename = function (plugin) {\n    return plugin && plugin.replace('gh-', '');\n};\n\nexports.isPluginIgnored = function (plugin) {\n    if (exports.getConfig().ignored_plugins.indexOf(exports.getPluginBasename(plugin)) > -1) {\n        return true;\n    }\n\n    return false;\n};\n\nexports.PLUGINS_PATH_KEY = PLUGINS_PATH_KEY;\n","/home/travis/build/npmtest/node-npmtest-gh/node_modules/gh/lib/logger.js":"/*\n * Copyright 2013-2015, All Rights Reserved.\n *\n * Code licensed under the BSD License:\n * https://github.com/node-gh/gh/blob/master/LICENSE.md\n *\n * @author Eduardo Lundgren <edu@rdo.io>\n * @author Zeno Rocha <zno.rocha@gmail.com>\n */\n\n'use strict';\n\nvar logger = {},\n    fs = require('fs'),\n    handlebars = require('handlebars'),\n    moment = require('moment'),\n    path = require('path'),\n    wrap = require('wordwrap').hard(0, 80),\n    colors = require('colors/safe');\n\nfunction stripHandlebarsNewLine(str) {\n    return str.replace(/[\\s\\t\\r\\n](\\{\\{[#\\/])/g, '$1');\n}\n\nlogger.debug = function () {\n    if (!process.env.GH_VERBOSE) {\n        return;\n    }\n\n    if (typeof arguments[0] === 'string') {\n        arguments[0] = 'DEBUG: ' + arguments[0];\n        console.log.apply(this, arguments);\n        return;\n    }\n\n    console.log('DEBUG:');\n    console.log.apply(this, arguments);\n};\n\nlogger.insane = function () {\n    if (!process.env.GH_VERBOSE_INSANE) {\n        return;\n    }\n\n    console.log.apply(this, arguments);\n};\n\nlogger.error = function () {\n    if (typeof arguments[0] === 'string') {\n        arguments[0] = 'fatal: ' + arguments[0];\n    }\n\n    console.error.apply(this, arguments);\n    process.exit(1);\n};\n\nlogger.warn = function () {\n    arguments[0] = 'warning: ' + arguments[0];\n    console.error.apply(this, arguments);\n};\n\nlogger.log = function () {\n    console.log.apply(this, arguments);\n};\n\nlogger.getDuration = function (start, opt_end) {\n    if (opt_end === undefined) {\n        opt_end = Date.now();\n    }\n\n    return moment.duration(moment(start).diff(opt_end)).humanize(true);\n};\n\nlogger.applyReplacements = function (output, replaceMap) {\n    var regexPattern;\n\n    for (regexPattern in replaceMap) {\n        if (replaceMap.hasOwnProperty(regexPattern)) {\n            output = output.replace(\n                new RegExp(regexPattern, 'g'), replaceMap[regexPattern]);\n        }\n    }\n\n    return output;\n};\n\nlogger.getErrorMessage = function (err) {\n    var msg;\n\n    // General normalizer\n    if (!err) {\n        return 'No error message.';\n    }\n\n    if (err.errors) {\n        return err.errors;\n    }\n\n    // Normalize github api error\n    if (!err.message) {\n        return err;\n    }\n\n    try {\n        msg = JSON.parse(err.message);\n    } catch(e) {\n        return err.message;\n    }\n\n    if (typeof msg === 'string') {\n        return msg;\n    }\n\n    if (msg.errors && msg.errors[0] && msg.errors[0].message) {\n        return msg.errors[0].message;\n    }\n\n    if (msg.message) {\n        return msg.message;\n    }\n\n    // Normalize git error\n    return err.message.replace('Command failed: fatal: ', '').trim();\n};\n\nlogger.compileTemplate = function (source, map) {\n    var template = handlebars.compile(source);\n\n    return logger.applyReplacements(template(map));\n};\n\nlogger.logTemplate = function (source, map) {\n    console.log(logger.compileTemplate(source, map || {}));\n};\n\nlogger.logTemplateFile = function (file, map) {\n    var templatePath,\n        source;\n\n    templatePath = path.join(file);\n\n    if (!fs.existsSync(templatePath)) {\n        templatePath = path.join(__dirname, 'cmds/templates', file);\n    }\n\n    source = fs.readFileSync(templatePath).toString();\n\n    logger.logTemplate(stripHandlebarsNewLine(source), map);\n};\n\nlogger.registerHelper = function (name, callback) {\n    handlebars.registerHelper(name, callback);\n};\n\nlogger.registerHelpers_ = function () {\n    handlebars.registerHelper('date', function (date) {\n        return logger.getDuration(date);\n    });\n\n    handlebars.registerHelper('compareLink', function () {\n        return this.options.github_host + this.options.user + '/' + this.options.repo +\n            '/compare/' + this.options.pullHeadSHA + '...' + this.options.currentSHA;\n    });\n\n    handlebars.registerHelper('forwardedLink', function () {\n        return this.options.github_host + this.options.fwd + '/' + this.options.repo + '/pull/' +\n            this.options.forwardedPull;\n    });\n\n    handlebars.registerHelper('link', function () {\n        return this.options.github_host + this.options.user + '/' + this.options.repo + '/pull/' +\n            this.options.number;\n    });\n\n    handlebars.registerHelper('submittedLink', function () {\n        return this.options.github_host + this.options.submit + '/' + this.options.repo + '/pull/' +\n            this.options.submittedPull;\n    });\n\n    handlebars.registerHelper('issueLink', function () {\n        return this.options.github_host + this.options.user + '/' + this.options.repo + '/issues/' +\n            this.options.number;\n    });\n\n    handlebars.registerHelper('gistLink', function () {\n        return this.options.github_gist_host + this.options.loggedUser + '/' + this.options.id;\n    });\n\n    handlebars.registerHelper('repoLink', function () {\n        return this.options.github_host + this.options.user + '/' + this.options.repo;\n    });\n\n    handlebars.registerHelper('wordwrap', function (text, padding, stripNewLines) {\n        var gutter = '';\n\n        if (stripNewLines !== false) {\n            text = text.replace(/[\\r\\n\\s\\t]+/g, ' ');\n        }\n\n        text = wrap(text).split('\\n');\n\n        if (padding > 0) {\n            gutter = (new Array(padding)).join(' ');\n        }\n\n        return text.join('\\n' + gutter);\n    });\n};\n\nlogger.registerHelpers_();\n\nlogger.colors = colors;\nmodule.exports = logger;\n","/home/travis/build/npmtest/node-npmtest-gh/node_modules/gh/lib/exec.js":"/*\n * Copyright 2013-2015, All Rights Reserved.\n *\n * Code licensed under the BSD License:\n * https://github.com/node-gh/gh/blob/master/LICENSE.md\n *\n * @author Zeno Rocha <zno.rocha@gmail.com>\n * @author Henrique Vicente <henriquevicente@gmail.com>\n */\n\n'use strict';\n\nvar child_process = require('child_process'),\n    logger = require('./logger');\n\nexports.spawnSync = function (cmd, args, options) {\n    var exec;\n\n    logger.debug('spawnSync: ' + cmd + ' ' + args.join(' '));\n\n    exec = child_process.spawnSync(cmd, args, options);\n\n    if (exec.error && exec.error.code === 'ENOENT' && process.platform === 'win32') {\n        logger.debug('Invoking patched sapwnSync due to Windows\\' libuv bug');\n        exec = child_process.spawnSync(cmd + '.cmd', args, options);\n    }\n\n    return {\n        stdout: exec.stdout.toString().trim(),\n        stderr: exec.stderr.toString().trim(),\n        status: exec.status\n    };\n};\n\nexports.spawnSyncStream = function (cmd, args, options) {\n    var proc,\n        err;\n\n    if (!options) {\n        options = {};\n    }\n\n    options.stdio = ['pipe', process.stdout, process.stderr];\n\n    logger.debug('spawnSyncStream: ' + cmd + ' ' + args.join(' '));\n\n    proc = child_process.spawnSync(cmd, args, options);\n\n    if (proc.status !== 0) {\n        err = new Error();\n        err.code = proc.status;\n        err.message = 'Child process terminated with error code ' + err.code;\n\n        throw err;\n    }\n\n    return proc;\n};\n\nexports.execSync = function (cmd, options) {\n    if (!options) {\n        options = {};\n    }\n\n    logger.debug('execSync: ' + cmd);\n\n    options.stdio = ['pipe', process.stdout, process.stderr];\n\n    return child_process.execSync(cmd, options);\n};\n\nexports.execSyncInteractiveStream = function (cmd, options) {\n    if (!options) {\n        options = {};\n    }\n\n    logger.debug('execSyncInteractiveStream: ' + cmd);\n\n    options.stdio = 'inherit';\n\n    return child_process.execSync(cmd, options);\n};\n","/home/travis/build/npmtest/node-npmtest-gh/node_modules/gh/lib/tracker.js":"/*\n * Copyright 2015, All Rights Reserved.\n *\n * Code licensed under the BSD License:\n * https://github.com/node-gh/gh/blob/master/LICENSE.md\n *\n * @author Henrique Vicente <henriquevicente@gmail.com>\n */\n\n'use strict';\n\nvar tracker,\n    Insight = require('insight'),\n    CmdAnonymizer = require('./cmd-anonymizer'),\n    pkg = require('../package.json'),\n    redaction = '********';\n\ntracker = new Insight({\n    trackingCode: pkg.trackingCode,\n    pkg: pkg\n});\n\ntracker.resolveCommand = function (cmd, commandDetails) {\n    var cmdAnonymizer;\n\n    if (!commandDetails) {\n        return cmd.join(' ').replace(/\\w+/g, redaction);\n    }\n\n    cmdAnonymizer = new CmdAnonymizer(commandDetails, redaction);\n\n    return cmdAnonymizer.resolveToString(cmd);\n};\n\ntracker.trackCommand = function (cmd, commandDetails) {\n    var tracking = pkg.name + ' ' + this.resolveCommand(cmd, commandDetails);\n\n    this.track(tracking.replace(/ /g, '%20'));\n};\n\nmodule.exports = tracker;\n","/home/travis/build/npmtest/node-npmtest-gh/node_modules/gh/lib/cmd-anonymizer.js":"/*\n * Copyright 2015, All Rights Reserved.\n *\n * Code licensed under the BSD License:\n * https://github.com/node-gh/gh/blob/master/LICENSE.md\n *\n * @author Henrique Vicente <henriquevicente@gmail.com>\n */\n\n'use strict';\n\nfunction CmdAnonymizer(commandDetails, redaction) {\n    this.last = null;\n    this.invoked = [];\n    this.redaction = redaction;\n    this.options = commandDetails.options;\n    this.shorthands = commandDetails.shorthands;\n}\n\nCmdAnonymizer.prototype.extractArgument = function (word) {\n    return word.replace(/-{0,2}/, '');\n};\n\nCmdAnonymizer.prototype.isOptionValue = function (option, value) {\n    var choice = this.options[option],\n        booleans = ['true', 'false'];\n\n    return ((choice instanceof Array && choice.indexOf(value) !== -1) ||\n        (choice === Boolean && booleans.indexOf(value.toLowerCase()) !== -1) ||\n        (typeof choice === 'string' && choice === value));\n};\n\nCmdAnonymizer.prototype.isValueInOptions = function (options, value) {\n    if (!(options instanceof Array)) {\n        return this.isOptionValue(options, value);\n    }\n\n    return options.some(function (each) {\n        return this.isOptionValue(this.extractArgument(each), value);\n    }, this);\n};\n\nCmdAnonymizer.prototype.classify = function (word) {\n    var arg = this.extractArgument(word),\n        whitelist = ['verbose', 'no-hooks'];\n\n    if (whitelist.indexOf(arg) === 0) {\n        this.invoked.push(word);\n        this.last = arg;\n        return;\n    }\n\n    if (this.shorthands && this.shorthands[arg]) {\n        this.invoked.push(word);\n        this.last = this.shorthands[arg];\n        return;\n    }\n\n    if (this.options && this.options[arg]) {\n        this.invoked.push(word);\n        this.last = arg;\n        return;\n    }\n\n    if (this.options && this.isValueInOptions(this.last, word)) {\n        this.invoked.push(word);\n        this.last = undefined;\n        return;\n    }\n\n    if (this.options && this.options[this.last] instanceof Array &&\n        this.options[this.last].indexOf(word) !== -1) {\n        this.invoked.push(word);\n        this.last = undefined;\n        return;\n    }\n\n    this.invoked.push(this.redaction);\n    this.last = undefined;\n};\n\nCmdAnonymizer.prototype.resolve = function (cmd) {\n    // quasi-strict white list approach (best-effort)\n\n    this.invoked.push(cmd.shift());\n\n    cmd.forEach(this.classify, this);\n\n    return this.invoked;\n};\n\nCmdAnonymizer.prototype.resolveToString = function (cmd) {\n    return this.resolve(cmd).join(' ');\n};\n\nmodule.exports = CmdAnonymizer;\n","/home/travis/build/npmtest/node-npmtest-gh/node_modules/gh/lib/git.js":"/*\n * Copyright 2013-2015, All Rights Reserved.\n *\n * Code licensed under the BSD License:\n * https://github.com/node-gh/gh/blob/master/LICENSE.md\n *\n * @author Eduardo Lundgren <edu@rdo.io>\n */\n\n'use strict';\n\nvar logger = require('./logger'),\n    exec = require('./exec'),\n    git_command = process.env.GH_GIT_COMMAND || 'git';\n\nexports.checkout = function (branch, newBranch) {\n    var args = ['checkout', branch];\n\n    if (newBranch) {\n        args.push('-B', newBranch);\n    }\n\n    return exec.spawnSyncStream(git_command, args);\n};\n\nexports.clone = function (url, folder) {\n    var args = ['clone', url];\n\n    if (folder) {\n        args.push(folder);\n    }\n\n    return exec.spawnSyncStream(git_command, args);\n};\n\nexports._merge = function (branch, type) {\n    var res;\n\n    try {\n        res = exec.spawnSyncStream(git_command, [type, branch]);\n    } catch(err) {\n        if (err.code && err.code !== 0) {\n            exec.spawnSyncStream(git_command, [type, '--abort']);\n            throw err;\n        }\n    }\n};\n\nexports.merge = function (branch) {\n    return this._merge(branch, 'merge');\n};\n\nexports.rebase = function (branch) {\n    return this._merge(branch, 'rebase');\n};\n\nexports.push = function (remote, branch) {\n    var args = ['push', remote];\n\n    if (branch) {\n        args.push(branch);\n    }\n\n    return exec.spawnSyncStream(git_command, args);\n};\n\nexports.fetch = function (repoUrl, headBranch, pullBranch) {\n    var args = ['fetch', repoUrl, headBranch + ':' + pullBranch, '--no-tags'];\n\n    return exec.spawnSyncStream(git_command, args);\n};\n\nexports.countUserAdjacentCommits = function () {\n    var git,\n        params,\n        commits = 0,\n        user = exports.getConfig('user.name'),\n        author;\n\n    do {\n        params = ['log', '-1', '--skip=' + commits, '--pretty=%an'];\n        git = exec.spawnSync(git_command, params);\n\n        if (git.status !== 0) {\n            logger.error(git.stderr);\n        }\n\n        author = git.stdout;\n\n        commits += 1;\n    } while (author === user);\n\n    commits -= 1;\n\n    return commits;\n};\n\nexports.deleteBranch = function (branch) {\n    var git = exec.spawnSync(git_command, ['branch', '-d', branch]);\n\n    if (git.status !== 0) {\n        logger.debug(git.stderr);\n    }\n\n    return git.stdout;\n};\n\nexports.findRoot = function () {\n    return exec.spawnSync(git_command, ['rev-parse', '--show-toplevel']).stdout;\n};\n\nexports.getCommitMessage = function (branch, number) {\n    var git,\n        params = ['log'];\n\n    if (!number) {\n        number = 1;\n    }\n\n    params.push('-' + number, '--first-parent', '--no-merges', '--pretty=%s');\n\n    if (branch) {\n        params.push(branch);\n    }\n\n    params.push('--');\n\n    git = exec.spawnSync(git_command, params);\n\n    if (git.status !== 0) {\n        logger.debug('Can\\'t get commit message.');\n        return;\n    }\n\n    return git.stdout;\n};\n\nexports.getConfig = function (key) {\n    var git = exec.spawnSync(git_command, ['config', '--get', key]);\n\n    if (git.status !== 0) {\n        throw new Error('No git config found for ' + key + '\\n');\n    }\n\n    return git.stdout;\n};\n\nexports.getCurrentBranch = function () {\n    var git = exec.spawnSync(git_command, ['symbolic-ref', '--short', 'HEAD']);\n\n    if (git.status !== 0) {\n        logger.debug('Can\\'t get current branch.');\n        return;\n    }\n\n    return git.stdout;\n};\n\nexports.getLastCommitMessage = function (branch) {\n    return exports.getCommitMessage(branch, 1);\n};\n\nexports.getLastCommitSHA = function () {\n    var git = exec.spawnSync(git_command, ['rev-parse', '--short', 'HEAD']);\n\n    if (git.status !== 0) {\n        throw new Error('Can\\'t retrieve last commit.');\n    }\n\n    return git.stdout;\n};\n\nexports.getRemoteUrl = function (remote) {\n    try {\n        return exports.getConfig('remote.' + remote + '.url');\n    }\n    catch(e) {\n        logger.debug('Can\\'t get remote URL.');\n        return;\n    }\n};\n\nexports.getRepoFromRemoteURL = function (url) {\n    var parsed = exports.parseRemoteUrl(url);\n\n    return parsed && parsed[1];\n};\n\nexports.getUserFromRemoteUrl = function (url) {\n    var parsed = exports.parseRemoteUrl(url);\n\n    return parsed && parsed[0];\n};\n\nexports.getRepo = function (remote) {\n    return exports.getRepoFromRemoteURL(exports.getRemoteUrl(remote));\n};\n\nexports.getUser = function (remote) {\n    return exports.getUserFromRemoteUrl(exports.getRemoteUrl(remote));\n};\n\nexports.parseRemoteUrl = function (url) {\n    var parsed = /[\\/:]([\\w-]+)\\/(.*?)(?:\\.git)?$/.exec(url);\n\n    if (parsed) {\n        parsed.shift();\n    }\n\n    return parsed;\n};\n","/home/travis/build/npmtest/node-npmtest-gh/node_modules/gh/lib/cmds/user.js":"/*\n * Copyright 2013-2015, All Rights Reserved.\n *\n * Code licensed under the BSD License:\n * https://github.com/node-gh/gh/blob/master/LICENSE.md\n *\n * @author Elad Elrom <elad.ny@gmail.com>\n * @author Zeno Rocha <zno.rocha@gmail.com>\n * @author Eduardo Lundgren <eduardo.lundgren@gmail.com>\n */\n\n'use strict';\n\n// -- Requires -------------------------------------------------------------------------------------\n\nvar base = require('../base'),\n    configs = require('../configs'),\n    logger = require('../logger'),\n    inquirer = require('inquirer'),\n    moment = require('moment'),\n    config = configs.getConfig();\n\n// -- Constructor ----------------------------------------------------------------------------------\n\nfunction User(options) {\n    this.options = options;\n}\n\n// -- Constants ------------------------------------------------------------------------------------\n\nUser.DETAILS = {\n    alias: 'us',\n    description: 'Provides the ability to login and logout if needed.',\n    commands: [\n        'login',\n        'logout',\n        'whoami'\n    ],\n    options: {\n        'login': Boolean,\n        'logout': Boolean,\n        'whoami': Boolean\n    },\n    shorthands: {\n        'l': ['--login'],\n        'L': ['--logout'],\n        'w': ['--whoami']\n    },\n    payload: function (payload, options) {\n        options.login = true;\n    }\n};\n\n// -- Commands -------------------------------------------------------------------------------------\n\nUser.prototype.run = function () {\n    var instance = this,\n        options = instance.options;\n\n    options.user = options.loggedUser;\n\n    if (options.login) {\n        if (User.hasCredentials()) {\n            logger.log('You\\'re logged in as ' + logger.colors.green(options.user));\n        }\n    }\n\n    if (options.logout) {\n        logger.log('Logging out of user ' + logger.colors.green(options.user));\n\n        User.logout();\n    }\n\n    if (options.whoami) {\n        logger.log(options.user);\n    }\n};\n\n// -- Static ---------------------------------------------------------------------------------------\n\nUser.authorize = function () {\n    config = configs.getConfig();\n\n    base.github.authenticate({\n        type: 'oauth',\n        token: config.github_token\n    });\n};\n\nUser.authorizationCallback_ = function (user, err, res) {\n    if (err) {\n        logger.error(err);\n        return;\n    }\n\n    if (res.token) {\n        configs.writeGlobalConfigCredentials(user, res.token);\n\n        User.authorize();\n    }\n\n    logger.log('Authentication succeed.');\n};\n\nUser.createAuthorization = function (opt_callback) {\n    logger.log('First we need authorization to use GitHub\\'s API. Login with your GitHub account.');\n\n    inquirer.prompt(\n        [\n            {\n                type: 'input',\n                message: 'Enter your GitHub user',\n                name: 'user'\n            },\n            {\n                type: 'password',\n                message: 'Enter your GitHub password',\n                name: 'password'\n            }\n        ], function (answers) {\n            var payload = {\n                note: 'Node GH (' + moment().format('MMMM Do YYYY, h:mm:ss a') + ')',\n                note_url: 'https://github.com/eduardolundgren/node-gh',\n                scopes: ['user', 'public_repo', 'repo', 'repo:status', 'delete_repo', 'gist']\n            };\n\n            base.github.authenticate({\n                type: 'basic',\n                username: answers.user,\n                password: answers.password\n            });\n\n            base.github.authorization.create(payload, function (err, res) {\n                var isTwoFactorAuthentication = err && err.message && err.message.indexOf('OTP') > 0;\n\n                if (isTwoFactorAuthentication) {\n                    User.twoFactorAuthenticator_(payload, answers.user, opt_callback);\n                }\n                else {\n                    User.authorizationCallback_(answers.user, err, res);\n                    opt_callback && opt_callback(err);\n                }\n            });\n        });\n};\n\nUser.hasCredentials = function () {\n    if (config.github_token && config.github_user) {\n        return true;\n    }\n\n    return false;\n};\n\nUser.login = function (opt_callback) {\n    if (User.hasCredentials()) {\n        User.authorize();\n        opt_callback && opt_callback();\n    }\n    else {\n        User.createAuthorization(opt_callback);\n    }\n};\n\nUser.logout = function () {\n    configs.removeGlobalConfig('github_user');\n    configs.removeGlobalConfig('github_token');\n};\n\nUser.twoFactorAuthenticator_ = function (payload, user, opt_callback) {\n    inquirer.prompt(\n        [\n            {\n                type: 'input',\n                message: 'Enter your two-factor code',\n                name: 'otp'\n            }\n        ], function (factor) {\n            if (!payload.headers) {\n                payload.headers = [];\n            }\n\n            payload.headers['X-GitHub-OTP'] = factor.otp;\n\n            base.github.authorization.create(payload, function (err, res) {\n                User.authorizationCallback_(user, err, res);\n                opt_callback && opt_callback(err);\n            });\n        });\n};\n\nexports.Impl = User;\n","/home/travis/build/npmtest/node-npmtest-gh/node_modules/gh/gulpfile.js":"'use strict';\n\nvar paths,\n    fs = require('fs'),\n    gulp = require('gulp'),\n    jshint = require('gulp-jshint'),\n    jscs = require('gulp-jscs'),\n    mocha = require('gulp-mocha'),\n    istanbul = require('gulp-istanbul'),\n    complexity = require('gulp-complexity'),\n    runSequence = require('run-sequence'),\n    open = require('open'),\n    help = require('./tasks/help'),\n    exec = require('./lib/exec');\n\npaths = {\n    lint: [\n        'lib/**/*.js', 'test/**/*.js', 'bin/**/*.js', 'tasks/**/*.js', '*.js'\n    ],\n    complexity: ['lib/**/*.js', 'test/**/*.js', 'tasks/**/*.js', '*.js'],\n    plato: 'lib',\n    cover: ['lib/**/*.js'],\n    unit: ['test/**/*.js', '!test/fixture/*.js'],\n    watch: ['lib/**/*.js'],\n    'coverage-report-directory': 'reports/coverage',\n    'coverage-report': 'reports/coverage/lcov-report/index.html',\n    'plato-report-directory': 'reports/complexity',\n    'plato-report': 'reports/complexity/index.html'\n};\n\nfunction lintTask() {\n    return gulp.src(paths.lint)\n        .pipe(jshint())\n        .pipe(jshint.reporter('jshint-stylish'))\n        .pipe(jshint.reporter('fail'))\n        .pipe(jscs());\n}\n\nfunction platoTask() {\n    exec.spawnSyncStream('node_modules/plato/bin/plato', [\n        '--dir',\n        paths['plato-report-directory'],\n        '--recurse',\n        '--title',\n        'Node GH',\n        '--jshint',\n        'test/.jshintrc',\n        'lib',\n        'test',\n        'bin',\n        'tasks',\n        'gulpfile.js'\n    ]);\n}\n\nfunction complexityTask() {\n    return gulp.src(paths.complexity)\n        .pipe(complexity({\n            halstead: 29,\n            cyclomatic: 17\n        }));\n}\n\nfunction coverTask() {\n    return gulp.src(paths.cover)\n        .pipe(istanbul({includeUntested: true}))\n        .pipe(istanbul.hookRequire());\n}\n\nfunction mochaTest() {\n    return gulp.src(paths.unit)\n        .pipe(mocha());\n}\n\nfunction unitTask() {\n    return mochaTest()\n        .pipe(istanbul.writeReports({\n            reporters: ['lcov', 'json'],\n            dir: paths['coverage-report-directory']\n        }));\n}\n\nfunction unitCiTask() {\n    return mochaTest()\n        .pipe(istanbul.writeReports({\n            dir: paths['coverage-report-directory']\n        }));\n}\n\nfunction testTask(done) {\n    return runSequence(\n        'lint',\n        // plato and gulp-complexity currently doesn't support ES6\n        // 'plato',\n        // 'complexity',\n        'unit',\n        done\n    );\n}\n\nfunction ciTask(done) {\n    return runSequence(\n        'lint',\n        // 'plato',\n        // 'complexity',\n        'unit-ci',\n        done\n    );\n}\n\nfunction coverageReportTask() {\n    var file = paths['coverage-report'];\n\n    if (!fs.existsSync(file)) {\n        console.error('Run gulp test first.');\n        return;\n    }\n\n    open(file);\n}\n\nfunction platoReportTask() {\n    var file = paths['plato-report'];\n\n    if (!fs.existsSync(file)) {\n        console.error('Run gulp test first.');\n        return;\n    }\n\n    open(file);\n}\n\nfunction watchTask() {\n    return gulp.watch(paths.watch, ['test']);\n}\n\nfunction ciReportsTask() {\n    open('https://node-gh.github.io/reports/');\n}\n\ngulp.task('default', help);\ngulp.task('help', help);\ngulp.task('lint', lintTask);\ngulp.task('plato', platoTask);\ngulp.task('complexity', complexityTask);\ngulp.task('test-cover', coverTask);\ngulp.task('unit', ['test-cover'], unitTask);\ngulp.task('unit-ci', ['test-cover'], unitCiTask);\ngulp.task('test', testTask);\ngulp.task('ci', ciTask);\ngulp.task('coverage-report', coverageReportTask);\ngulp.task('plato-report', platoReportTask);\ngulp.task('watch', watchTask);\ngulp.task('ci-reports', ciReportsTask);\n","/home/travis/build/npmtest/node-npmtest-gh/node_modules/gh/lib/hooks.js":"/*\n * Copyright 2013-2015, All Rights Reserved.\n *\n * Code licensed under the BSD License:\n * https://github.com/node-gh/gh/blob/master/LICENSE.md\n *\n * @author Eduardo Lundgren <edu@rdo.io>\n */\n\n'use strict';\n\nvar async = require('async'),\n    configs = require('./configs'),\n    exec = require('./exec'),\n    truncate = require('truncate'),\n    logger = require('./logger'),\n    config = configs.getConfig(true);\n\nexports.createContext = function (scope) {\n    return {\n        options: scope.options,\n        signature: config.signature\n    };\n};\n\nexports.getHooksArrayFromPath_ = function (path, opt_config) {\n    var keys = path.split('.'),\n        key = keys.shift(),\n        hooks;\n\n    opt_config = opt_config || config;\n\n    hooks = opt_config.hooks || {};\n\n    while (hooks[key]) {\n        hooks = hooks[key];\n        key = keys.shift();\n    }\n\n    return Array.isArray(hooks) ? hooks : [];\n};\n\nexports.getHooksFromPath = function (path) {\n    var hooks,\n        plugins = configs.getPlugins(),\n        pluginHooks = [];\n\n    // First, load all core hooks for the specified path.\n    hooks = exports.getHooksArrayFromPath_(path);\n\n    // Second, search all installed plugins and load the hooks for each into\n    // core hooks array.\n    plugins.forEach(function (plugin) {\n        var pluginConfig;\n\n        plugin = configs.getPluginBasename(plugin);\n\n        if (config.plugins && !configs.isPluginIgnored(plugin)) {\n            pluginConfig = config.plugins[plugin];\n\n            if (pluginConfig) {\n                pluginHooks = pluginHooks.concat(\n                    exports.getHooksArrayFromPath_(path, pluginConfig));\n            }\n        }\n    });\n\n    return hooks.concat(pluginHooks);\n};\n\nexports.invoke = function (path, scope, opt_callback) {\n    var after = exports.getHooksFromPath(path + '.after'),\n        before = exports.getHooksFromPath(path + '.before'),\n        beforeOperations,\n        afterOperations,\n        options = scope.options,\n        context;\n\n    if (options.hooks === false || process.env.NODEGH_HOOK_IS_LOCKED) {\n        opt_callback && opt_callback();\n        return;\n    }\n\n    context = exports.createContext(scope);\n\n    beforeOperations = [\n\n        function (callback) {\n            exports.setupPlugins_(context, 'setupBeforeHooks', callback);\n        }\n    ];\n\n    before.forEach(function (cmd) {\n        beforeOperations.push(exports.wrapCommand_(cmd, context, 'before'));\n    });\n\n    afterOperations = [\n\n        function (callback) {\n            exports.setupPlugins_(context, 'setupAfterHooks', callback);\n        }\n    ];\n\n    after.forEach(function (cmd) {\n        afterOperations.push(exports.wrapCommand_(cmd, context, 'after'));\n    });\n\n    afterOperations.push(function (callback) {\n        process.env.NODEGH_HOOK_IS_LOCKED = false;\n        callback();\n    });\n\n    process.env.NODEGH_HOOK_IS_LOCKED = true;\n\n    async.series(beforeOperations, function () {\n        opt_callback && opt_callback(function () {\n            async.series(afterOperations);\n        });\n    });\n};\n\nexports.setupPlugins_ = function (context, setupFn, opt_callback) {\n    var plugins = configs.getPlugins(),\n        operations = [];\n\n    plugins.forEach(function (plugin) {\n        try {\n            plugin = configs.getPlugin(plugin);\n        }\n        catch(e) {\n            logger.warn('Can\\'t get ' + plugin + ' plugin.');\n        }\n\n        if (plugin && plugin[setupFn]) {\n            operations.push(function (callback) {\n                plugin[setupFn](context, callback);\n            });\n        }\n    });\n\n    async.series(operations, function () {\n        opt_callback && opt_callback();\n    });\n};\n\nexports.wrapCommand_ = function (cmd, context, when) {\n    return function (callback) {\n        var raw = logger.compileTemplate(cmd, context);\n\n        if (!raw) {\n            callback && callback();\n            return;\n        }\n\n        logger.log(logger.colors.cyan('[hook]'), truncate(raw.trim(), 120));\n\n        try {\n            exec.execSyncInteractiveStream(raw, {cwd: process.cwd()});\n        } catch(e) {\n            logger.debug('[' + when + ' hook failure]');\n        } finally {\n            logger.debug(logger.colors.cyan('[end of ' + when + ' hook]'));\n        }\n\n        callback && callback();\n    };\n};\n","/home/travis/build/npmtest/node-npmtest-gh/node_modules/gh/lib/rest-api-client.js":"'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError('Cannot call a class as a function'); } }\n\nvar _request = require('request');\nvar http = require('http');\nvar _url = require('url');\nvar lodash = require('lodash');\nvar logger = require('./logger');\n\nvar RestApiClient = (function () {\n    function RestApiClient(options) {\n        _classCallCheck(this, RestApiClient);\n\n        options = lodash.merge(this.DEFAULT_CONFIG, options);\n        this.options = options;\n    }\n\n    RestApiClient.prototype.encode = function encode() {\n        return encodeURIComponent.apply(this, arguments);\n    };\n\n    RestApiClient.prototype.url = function url(pathname, query) {\n        var options = this.options;\n        var uri = _url.format({\n            protocol: options.protocol,\n            hostname: options.host,\n            port: options.port,\n            pathname: options.base + pathname,\n            query: query\n        });\n\n        return decodeURIComponent(uri);\n    };\n\n    RestApiClient.prototype.authorize = function authorize(p) {\n        var options = this.options;\n\n        if (p.oauth) {\n            p.oauth = options.oauth;\n            return;\n        }\n\n        if (typeof options.user === 'string') {\n            p.auth = {\n                'user': options.user,\n                'pass': options.password\n            };\n        }\n    };\n\n    RestApiClient.prototype.request = function request(method, path, params) {\n        if (typeof path === 'object') {\n            var args = Array.from(path);\n            args.unshift(method);\n            return this.request.apply(this, args);\n        }\n\n        var options = this.options;\n\n        var p = {\n            strictSSL: options.strictSSL,\n            method: method,\n            uri: this.url(path),\n            json: true,\n            followAllRedirects: true\n        };\n\n        if (params) {\n            p = lodash.merge(p, params);\n        }\n\n        this.authorize(p);\n\n        var id = Math.floor(Math.random() * 10000000);\n        var begin = new Date().getTime();\n\n        return new Promise(function (resolve, reject) {\n            logger.debug('New request #' + id + ' started at ' + begin + ':\\n' + method + ' ' + p.uri);\n            logger.insane(p);\n            _request(p, function (error, response) {\n                var end = new Date().getTime();\n                logger.debug('End of request #' + id + ' at ' + end + ' (' + (end - begin) + 'ms)' + ' with status code: ' + (response && response.statusCode));\n\n                if (response) {\n                    logger.insane('Response headers:');\n                    logger.insane(response.headers);\n                    logger.debug('Response body');\n                    logger.debug(response.body);\n                }\n\n                if (error) {\n                    reject(error);\n                    return;\n                }\n\n                if (response.statusCode < 200 || response.statusCode > 399) {\n                    reject({\n                        error: response.statusCode + ' ' + http.STATUS_CODES[response.statusCode],\n                        code: response.statusCode,\n                        msg: http.STATUS_CODES[response.statusCode],\n                        response: response\n                    });\n                    return;\n                }\n\n                resolve(response);\n            });\n        });\n    };\n\n    RestApiClient.prototype.get = function get() {\n        return this.request('GET', arguments);\n    };\n\n    RestApiClient.prototype.post = function post() {\n        return this.request('POST', arguments);\n    };\n\n    RestApiClient.prototype.put = function put() {\n        return this.request('PUT', arguments);\n    };\n\n    RestApiClient.prototype['delete'] = function _delete() {\n        return this.request('DELETE', arguments);\n    };\n\n    return RestApiClient;\n})();\n\nRestApiClient.prototype.DEFAULT_CONFIG = {\n    protocol: 'https',\n    host: 'localhost',\n    port: '443',\n    user: 'user',\n    password: 'password',\n    base: '',\n    // oauth: undefined,\n    strictSSL: true\n};\n\nmodule.exports = RestApiClient;\n","/home/travis/build/npmtest/node-npmtest-gh/node_modules/gh/tasks/help.js":"'use strict';\n\nvar colors = require('colors'),\n    header,\n    content;\n\nheader = '\\nusage: gulp <command>\\n\\n' +\n    'The most commonly used gh tasks are:';\n\ncontent = {\n    'lint': 'Lint code',\n    'complexity': 'Show code complexity analysis summary',\n    'plato': 'Create advanced code complexity static analysis in HTML',\n    'unit': 'Run unit tests and create code coverage report in HTML',\n    'test': 'Run all code quality tools',\n    'coverage-report': 'Open code coverage report',\n    'plato-report': 'Open code complexity and static analysis report',\n    'watch': 'Watch for any changes and run linting and tests',\n    'ci-reports': 'Open CI reports page'\n};\n\nfunction help() {\n    var output = '',\n        spacing = 0,\n        methods;\n\n    methods = Object.keys(content);\n\n    methods.forEach(function (item) {\n        if (spacing < item.length) {\n            spacing = item.length + 1;\n        }\n    });\n\n    methods.forEach(function (item) {\n        output += '  ' + colors.cyan(item) +\n            new Array(spacing - item.length + 2).join(' ') +\n            content[item] + '\\n';\n    });\n\n    console.log([header, output].join('\\n'));\n}\n\nmodule.exports = help;\n","/home/travis/build/npmtest/node-npmtest-gh/node_modules/gh/lib/cmds/alias.js":"/*\n * Copyright 2013-2015, All Rights Reserved.\n *\n * Code licensed under the BSD License:\n * https://github.com/node-gh/gh/blob/master/LICENSE.md\n *\n * @author Eduardo Lundgren <eduardo.lundgren@gmail.com>\n * @author Zeno Rocha <zno.rocha@gmail.com>\n */\n\n'use strict';\n\n// -- Requires -------------------------------------------------------------------------------------\n\nvar base = require('../base'),\n    configs = require('../configs'),\n    logger = require('../logger'),\n    config = base.getConfig();\n\n// -- Constructor ----------------------------------------------------------------------------------\n\nfunction Alias(options) {\n    this.options = options;\n}\n\n// -- Constants ------------------------------------------------------------------------------------\n\nAlias.DETAILS = {\n    alias: 'al',\n    description: 'Create alias for a username.',\n    commands: [\n        'add',\n        'list',\n        'remove'\n    ],\n    options: {\n        'add': String,\n        'list': Boolean,\n        'remove': String,\n        'user': String\n    },\n    shorthands: {\n        'a': ['--add'],\n        'l': ['--list'],\n        'r': ['--remove'],\n        'u': ['--user']\n    },\n    payload: function (payload, options) {\n        if (payload[0]) {\n            options.add = payload[0];\n            options.user = payload[1];\n        }\n        else {\n            options.list = true;\n        }\n    }\n};\n\n// -- Commands -------------------------------------------------------------------------------------\n\nAlias.prototype.run = function () {\n    var instance = this,\n        options = instance.options;\n\n    if (options.add) {\n        if (!options.user) {\n            logger.error('You must specify an user, try --user username.');\n        }\n\n        logger.debug('Creating alias ' + options.add);\n        instance.add();\n    }\n\n    if (options.list) {\n        instance.list(function (err, data) {\n            var item;\n\n            for (item in data) {\n                if (data.hasOwnProperty(item)) {\n                    logger.log(logger.colors.cyan(item) + ': ' + logger.colors.magenta(data[item]));\n                }\n            }\n        });\n    }\n\n    if (options.remove) {\n        logger.debug('Removing alias ' + options.remove);\n        instance.remove();\n    }\n};\n\nAlias.prototype.add = function () {\n    var instance = this,\n        options = instance.options;\n\n    configs.writeGlobalConfig('alias.' + options.add, options.user);\n};\n\nAlias.prototype.list = function (opt_callback) {\n    opt_callback && opt_callback(null, config.alias);\n};\n\nAlias.prototype.remove = function () {\n    var instance = this,\n        options = instance.options;\n\n    delete config.alias[options.remove];\n\n    configs.writeGlobalConfig('alias', config.alias);\n};\n\nexports.Impl = Alias;\n","/home/travis/build/npmtest/node-npmtest-gh/node_modules/gh/lib/cmds/gists.js":"/*\n * Copyright 2013-2015, All Rights Reserved.\n *\n * Code licensed under the BSD License:\n * https://github.com/node-gh/gh/blob/master/LICENSE.md\n *\n * @author Henrique Vicente <henriquevicente@gmail.com>\n * @author Eduardo Lundgren <eduardo.lundgren@gmail.com>\n * @author Zeno Rocha <zno.rocha@gmail.com>\n */\n\n'use strict';\n\n// -- Requires -------------------------------------------------------------------------------------\n\nvar base = require('../base'),\n    hooks = require('../hooks'),\n    inquirer = require('inquirer'),\n    logger = require('../logger'),\n    openUrl = require('open'),\n    config = base.getConfig();\n\n// -- Constructor ----------------------------------------------------------------------------------\n\nfunction Gists(options) {\n    this.options = options;\n}\n\n// -- Constants ------------------------------------------------------------------------------------\n\nGists.DETAILS = {\n    alias: 'gi',\n    description: 'Provides a set of util commands to work with Gists.',\n    iterative: 'delete',\n    commands: [\n        'browser',\n        'delete',\n        'fork',\n        'list',\n        'new'\n    ],\n    options: {\n        'browser': Boolean,\n        'content': String,\n        'delete': [String, Array],\n        'description': String,\n        'fork': String,\n        'id': String,\n        'list': Boolean,\n        'new': String,\n        'private': Boolean,\n        'user': String\n    },\n    shorthands: {\n        'B': ['--browser'],\n        'c': ['--content'],\n        'D': ['--delete'],\n        'd': ['--description'],\n        'f': ['--fork'],\n        'i': ['--id'],\n        'l': ['--list'],\n        'N': ['--new'],\n        'p': ['--private'],\n        'u': ['--user']\n    },\n    payload: function (payload, options) {\n        options.list = true;\n    }\n};\n\n// -- Commands -------------------------------------------------------------------------------------\n\nGists.prototype.run = function () {\n    var instance = this,\n        operations,\n        options = instance.options;\n\n    instance.config = config;\n\n    if (options.paste) {\n        logger.error('Sorry, this functionality was removed.');\n        return;\n    }\n\n    if (options.browser) {\n        instance.browser(options.id || options.loggedUser);\n    }\n\n    if (options.delete) {\n        hooks.invoke('gists.delete', instance, function (afterHooksCallback) {\n            logger.log('Deleting gist ' + logger.colors.green(options.loggedUser + '/' + options.delete));\n\n            inquirer.prompt(\n                [\n                    {\n                        type: 'input',\n                        message: 'Are you sure? This action CANNOT be undone. [y/N]',\n                        name: 'confirmation'\n                    }\n                ], function (answers) {\n                    if (answers.confirmation.toLowerCase() === 'y') {\n                        instance.delete(options.delete, function (err) {\n                            if (err) {\n                                logger.error('Can\\'t delete gist.');\n                                return;\n                            }\n                        });\n\n                        afterHooksCallback();\n                    }\n                    else {\n                        logger.log('Not deleted.');\n                    }\n                });\n        });\n    }\n\n    if (options.fork) {\n        hooks.invoke('gists.fork', instance, function (afterHooksCallback) {\n            logger.log('Forking gist on ' + logger.colors.green(options.loggedUser));\n\n            instance.fork(options.fork, function (err, gist) {\n                if (err) {\n                    logger.error(JSON.parse(err.message).message);\n                    return;\n                }\n\n                logger.log(gist.html_url);\n                afterHooksCallback();\n            });\n        });\n    }\n\n    if (options.list) {\n        logger.log('Listing gists for ' + logger.colors.green(options.user));\n\n        instance.list(options.user, function (err) {\n            if (err) {\n                logger.error('Can\\'t list gists for ' + options.user + '.');\n                return;\n            }\n        });\n    }\n\n    if (options.new) {\n        hooks.invoke('gists.new', instance, function (afterHooksCallback) {\n            var privacy = (options.private) ? 'private' : 'public';\n\n            operations = [];\n            options.new = options.new;\n\n            logger.log('Creating ' + logger.colors.magenta(privacy) + ' gist on ' +\n                logger.colors.green(options.loggedUser));\n\n            instance.new(options.new, options.content, function (err, gist) {\n                if (gist) {\n                    options.id = gist.id;\n                }\n\n                if (err) {\n                    logger.error('Can\\'t create gist. ' + JSON.parse(err.message).message);\n                    return;\n                }\n\n                logger.log(gist.html_url);\n\n                afterHooksCallback();\n            });\n        });\n    }\n};\n\nGists.prototype.browser = function (gist) {\n    openUrl(config.github_gist_host + gist);\n};\n\nGists.prototype.delete = function (id, opt_callback) {\n    var payload = {\n        id: id\n    };\n\n    base.github.gists.delete(payload, opt_callback);\n};\n\nGists.prototype.fork = function (id, opt_callback) {\n    var payload = {\n        id: id\n    };\n\n    base.github.gists.fork(payload, opt_callback);\n};\n\nGists.prototype.list = function (user, opt_callback) {\n    var instance = this,\n        payload;\n\n    payload = {\n        user: user\n    };\n\n    base.github.gists.getFromUser(payload, function (err, gists) {\n        instance.listCallback_(err, gists, opt_callback);\n    });\n};\n\nGists.prototype.listCallback_ = function (err, gists, opt_callback) {\n    var instance = this,\n        options = instance.options;\n\n    if (err && !options.all) {\n        logger.error(logger.getErrorMessage(err));\n    }\n\n    if (gists && gists.length > 0) {\n        gists.forEach(function (gist) {\n            logger.log(logger.colors.yellow(gist.owner.login + '/' + gist.id) +\n                ' ' + logger.getDuration(gist.updated_at));\n\n            if (gist.description) {\n                logger.log(gist.description);\n            }\n\n            logger.log(logger.colors.blue(gist.html_url) + '\\n');\n        });\n\n        opt_callback && opt_callback(err);\n    }\n};\n\nGists.prototype.new = function (name, content, opt_callback) {\n    var instance = this,\n        file = {},\n        options = instance.options,\n        payload;\n\n    options.description = options.description || '';\n\n    file[name] = {\n        content: content\n    };\n\n    payload = {\n        description: options.description,\n        files: file,\n        public: !options.private\n    };\n\n    base.github.gists.create(payload, opt_callback);\n};\n\nexports.Impl = Gists;\n","/home/travis/build/npmtest/node-npmtest-gh/node_modules/gh/lib/cmds/hello.js":"/*\n * Copyright 2013-2015, All Rights Reserved.\n *\n * Code licensed under the BSD License:\n * https://github.com/node-gh/gh/blob/master/LICENSE.md\n *\n * @author Author <email@email.com>\n */\n\n'use strict';\n\n// -- Requires -------------------------------------------------------------------------------------\n\nvar logger = require('../logger');\n\n// -- Constructor ----------------------------------------------------------------------------------\n\nfunction Hello(options) {\n    this.options = options;\n}\n\n// -- Constants ------------------------------------------------------------------------------------\n\nHello.DETAILS = {\n    alias: 'he',\n    description: 'Hello world example. Copy to start a new command.',\n    commands: [\n        'world'\n    ],\n    options: {\n        'world': Boolean\n    },\n    shorthands: {\n        'w': ['--world']\n    },\n    payload: function (payload, options) {\n        options.world = true;\n    }\n};\n\n// -- Commands -------------------------------------------------------------------------------------\n\nHello.prototype.run = function () {\n    var instance = this,\n        options = instance.options;\n\n    if (options.world) {\n        instance.world();\n    }\n};\n\nHello.prototype.world = function () {\n    logger.log('hello world :)');\n};\n\nexports.Impl = Hello;\n","/home/travis/build/npmtest/node-npmtest-gh/node_modules/gh/lib/cmds/issue.js":"/*\n * Copyright 2013-2015, All Rights Reserved.\n *\n * Code licensed under the BSD License:\n * https://github.com/node-gh/gh/blob/master/LICENSE.md\n *\n * @author Zeno Rocha <zno.rocha@gmail.com>\n * @author Eduardo Lundgren <edu@rdo.io>\n */\n\n'use strict';\n\n// -- Requires -------------------------------------------------------------------------------------\n\nvar async = require('async'),\n    base = require('../base'),\n    hooks = require('../hooks'),\n    logger = require('../logger'),\n    openUrl = require('open'),\n    config = base.getConfig();\n\n// -- Constructor ----------------------------------------------------------------------------------\n\nfunction Issue(options) {\n    this.options = options;\n\n    if (!options.repo && !options.all) {\n        logger.error('You must specify a Git repository with a GitHub remote to run this command');\n    }\n}\n\n// -- Constants ------------------------------------------------------------------------------------\n\nIssue.DETAILS = {\n    alias: 'is',\n    description: 'Provides a set of util commands to work with Issues.',\n    iterative: 'number',\n    commands: [\n        'browser',\n        'close',\n        'comment',\n        'list',\n        'new',\n        'open',\n        'search'\n    ],\n    options: {\n        'all': Boolean,\n        'assignee': String,\n        'browser': Boolean,\n        'close': Boolean,\n        'comment': String,\n        'detailed': Boolean,\n        'label': String,\n        'list': Boolean,\n        'message': String,\n        'milestone': [Number, String],\n        'no-milestone': Boolean,\n        'new': Boolean,\n        'number': [String, Array],\n        'open': Boolean,\n        'remote': String,\n        'repo': String,\n        'search': String,\n        'state': ['open', 'closed'],\n        'title': String,\n        'user': String\n    },\n    shorthands: {\n        'a': ['--all'],\n        'A': ['--assignee'],\n        'B': ['--browser'],\n        'C': ['--close'],\n        'c': ['--comment'],\n        'd': ['--detailed'],\n        'L': ['--label'],\n        'l': ['--list'],\n        'm': ['--message'],\n        'M': ['--milestone'],\n        'N': ['--new'],\n        'n': ['--number'],\n        'o': ['--open'],\n        'r': ['--repo'],\n        's': ['--search'],\n        'S': ['--state'],\n        't': ['--title'],\n        'u': ['--user']\n    },\n    payload: function (payload, options) {\n        if (payload[0]) {\n            if (/^\\d+$/.test(payload[0])) {\n                options.browser = true;\n                options.number = payload[0];\n                return;\n            }\n\n            options.new = true;\n            options.title = options.title || payload[0];\n            options.message = options.message || payload[1];\n        }\n        else {\n            options.list = true;\n        }\n    }\n};\n\nIssue.STATE_CLOSED = 'closed';\nIssue.STATE_OPEN = 'open';\n\n// -- Commands -------------------------------------------------------------------------------------\n\nIssue.prototype.run = function () {\n    var instance = this,\n        options = instance.options;\n\n    instance.config = config;\n\n    options.state = options.state || Issue.STATE_OPEN;\n\n    if (options.browser) {\n        instance.browser(options.user, options.repo, options.number);\n    }\n\n    if (options.close) {\n        hooks.invoke('issue.close', instance, function (afterHooksCallback) {\n            options.state = Issue.STATE_CLOSED;\n\n            logger.log('Closing issue ' + logger.colors.green('#' + options.number) +\n                ' on ' + logger.colors.green(options.user + '/' + options.repo));\n\n            instance.close(function (err, issue) {\n                if (err) {\n                    logger.error('Can\\'t close issue.');\n                    return;\n                }\n\n                logger.log(issue.html_url);\n                afterHooksCallback();\n            });\n        });\n    }\n\n    if (options.comment) {\n        logger.log('Adding comment on issue ' + logger.colors.green('#' + options.number));\n\n        instance.comment(function (err, issue) {\n            if (err) {\n                logger.error('Can\\'t add comment.');\n                return;\n            }\n\n            logger.log(issue.html_url);\n        });\n    }\n\n    if (options.list) {\n        if (options.all) {\n            logger.log('Listing ' + logger.colors.green(options.state) + ' issues for ' +\n                logger.colors.green(options.user));\n\n            instance.listFromAllRepositories(function (err) {\n                if (err) {\n                    logger.error('Can\\'t list issues for ' + options.user + '.');\n                    return;\n                }\n            });\n        }\n        else {\n            logger.log('Listing ' + logger.colors.green(options.state) +\n                ' issues on ' + logger.colors.green(options.user + '/' + options.repo));\n\n            instance.list(options.user, options.repo, function (err) {\n                if (err) {\n                    logger.error('Can\\'t list issues on ' + options.user + '/' + options.repo);\n                    return;\n                }\n            });\n        }\n    }\n\n    if (options.new) {\n        hooks.invoke('issue.new', instance, function (afterHooksCallback) {\n            logger.log('Creating a new issue on ' + logger.colors.green(options.user + '/' + options.repo));\n\n            instance.new(function (err, issue) {\n                if (err) {\n                    logger.error('Can\\'t create new issue.');\n                    return;\n                }\n\n                if (issue) {\n                    options.number = issue.number;\n                }\n\n                logger.log(issue.html_url);\n                afterHooksCallback();\n            });\n        });\n    }\n\n    if (options.open) {\n        hooks.invoke('issue.open', instance, function (afterHooksCallback) {\n            logger.log('Opening issue ' + logger.colors.green('#' + options.number) +\n                ' on ' + logger.colors.green(options.user + '/' + options.repo));\n\n            instance.open(function (err, issue) {\n                if (err) {\n                    logger.error('Can\\'t open issue.');\n                    return;\n                }\n\n                logger.log(issue.html_url);\n                afterHooksCallback();\n            });\n        });\n    }\n\n    if (options.search) {\n        var repo = options.repo;\n        if (options.all) {\n            repo = undefined;\n            logger.log('Searching for ' + logger.colors.green(options.search) +\n                ' in issues for ' + logger.colors.green(options.user));\n        } else {\n            logger.log('Searching for ' + logger.colors.green(options.search) +\n                ' in issues on ' + logger.colors.green(options.user + '/' + options.repo));\n        }\n\n        instance.search(options.user, repo, function (err) {\n            if (err) {\n                if (options.all) {\n                    logger.error('Can\\'t search issues for ' + options.user);\n                    return;\n                } else {\n                    logger.error('Can\\'t search issues on ' + options.user + '/' + options.repo);\n                    return;\n                }\n            }\n        });\n    }\n\n};\n\nIssue.prototype.browser = function (user, repo, number) {\n    if (!number) {\n        number = '';\n    }\n\n    openUrl(config.github_host + user + '/' + repo + '/issues/' + number);\n};\n\nIssue.prototype.close = function (opt_callback) {\n    var instance = this;\n\n    instance.getIssue_(function (err, issue) {\n        if (err) {\n            opt_callback && opt_callback(err);\n        }\n        else {\n            instance.editIssue_(issue.title, Issue.STATE_CLOSED, opt_callback);\n        }\n    });\n};\n\nIssue.prototype.comment = function (opt_callback) {\n    var instance = this,\n        options = instance.options,\n        body,\n        payload;\n\n    body = logger.applyReplacements(options.comment, config.replace) + config.signature;\n\n    payload = {\n        body: body,\n        number: options.number,\n        repo: options.repo,\n        user: options.user\n    };\n\n    base.github.issues.createComment(payload, opt_callback);\n};\n\nIssue.prototype.editIssue_ = function (title, state, opt_callback) {\n    var instance = this,\n        options = instance.options,\n        payload;\n\n    options.label = options.label || [];\n\n    payload = {\n        labels: options.label,\n        number: options.number,\n        assignee: options.assignee,\n        milestone: options.milestone,\n        repo: options.repo,\n        state: state,\n        title: title,\n        user: options.user\n    };\n\n    base.github.issues.edit(payload, opt_callback);\n};\n\nIssue.prototype.getIssue_ = function (opt_callback) {\n    var instance = this,\n        options = instance.options,\n        payload;\n\n    payload = {\n        number: options.number,\n        repo: options.repo,\n        user: options.user\n    };\n\n    base.github.issues.getRepoIssue(payload, opt_callback);\n};\n\nIssue.prototype.list = function (user, repo, opt_callback) {\n    var instance = this,\n        options = instance.options,\n        operations = [],\n        payload;\n\n    options.label = options.label || '';\n\n    payload = {\n        labels: options.label,\n        repo: repo,\n        state: options.state,\n        user: user\n    };\n\n    if (options['no-milestone']) {\n        payload.milestone = 'none';\n    } else if (options.milestone) {\n        payload.milestone = options.milestone;\n    }\n\n    if (options.milestone) {\n        operations.push(function (callback) {\n            base.github.issues.getAllMilestones({\n                repo: repo,\n                user: user\n            }, function (err, results) {\n                if (err) {\n                    logger.warn(err.message);\n                }\n\n                results.some(function (milestone) {\n                    if (options.milestone === milestone.title) {\n                        logger.debug('Milestone ' + milestone.title + ' number: ' + milestone.number);\n                        payload.milestone = milestone.number;\n                        return true;\n                    }\n                });\n\n                callback();\n            });\n        });\n    }\n\n    if (options.assignee) {\n        payload.assignee = options.assignee;\n    }\n\n    operations.push(function (callback) {\n        base.github.issues.repoIssues(payload, callback);\n    });\n\n    async.series(operations, function (err, results) {\n        var issues = [];\n\n        if (err && !options.all) {\n            logger.error(logger.getErrorMessage(err));\n        }\n\n\n        results.forEach(function (result) {\n            if (result) {\n                issues = issues.concat(result);\n            }\n        });\n\n        issues.sort(function (a, b) {\n            return a.number > b.number ? -1 : 1;\n        });\n\n        if (issues && issues.length > 0) {\n            issues.forEach(function (issue) {\n                var labels = issue.label || [];\n\n                logger.log(logger.colors.green('#' + issue.number) + ' ' + issue.title + ' ' +\n                    logger.colors.magenta('@' + issue.user.login + ' (' + logger.getDuration(issue.created_at) + ')'));\n\n                if (options.detailed) {\n                    if (issue.body) {\n                        logger.log(issue.body);\n                    }\n\n                    labels.forEach(function (label) {\n                        labels.push(label.name);\n                    });\n\n                    if (labels.length > 0) {\n                        logger.log(logger.colors.green('label: ') + labels.join(', '));\n                    }\n\n                    if (issue.milestone) {\n                        logger.log(logger.colors.green('milestone: ') +\n                            issue.milestone.title + ' - ' + issue.milestone.number);\n                    }\n\n                    logger.log(logger.colors.blue(issue.html_url));\n                }\n            });\n\n            opt_callback && opt_callback(err);\n        }\n    });\n};\n\nIssue.prototype.listFromAllRepositories = function (opt_callback) {\n    var instance = this,\n        options = instance.options,\n        payload;\n\n    payload = {\n        type: 'all',\n        user: options.user\n    };\n\n    base.github.repos.getAll(payload, function (err, repositories) {\n        if (err) {\n            opt_callback && opt_callback(err);\n        }\n        else {\n            repositories.forEach(function (repository) {\n                instance.list(repository.owner.login, repository.name, opt_callback);\n            });\n        }\n    });\n};\n\nIssue.prototype.new = function (opt_callback) {\n    var instance = this,\n        options = instance.options,\n        body,\n        payload;\n\n    if (options.message) {\n        body = logger.applyReplacements(options.message, config.replace);\n    }\n\n    if (options.label) {\n        options.label = options.label.split(',');\n    }\n    else {\n        options.label = [];\n    }\n\n    payload = {\n        assignee: options.assignee,\n        body: body,\n        repo: options.repo,\n        title: options.title,\n        user: options.user,\n        labels: options.label\n    };\n\n    base.github.issues.create(payload, opt_callback);\n};\n\nIssue.prototype.open = function (opt_callback) {\n    var instance = this;\n\n    instance.getIssue_(function (err, issue) {\n        if (err) {\n            opt_callback && opt_callback(err);\n        }\n        else {\n            instance.editIssue_(issue.title, Issue.STATE_OPEN, opt_callback);\n        }\n    });\n};\n\nIssue.prototype.search = function (user, repo, opt_callback) {\n    var instance = this,\n        options = instance.options,\n        operations = [],\n        query = [],\n        payload;\n\n    options.label = options.label || '';\n\n    if (!options.all) {\n        query.push('repo:' + repo);\n    }\n\n    query.push('user:' + user);\n    query.push(options.search);\n    query = query.join('+');\n\n    payload = {\n        q: query,\n        type: 'Issues'\n    };\n\n    operations.push(function (callback) {\n        base.github.search.issues(payload, callback);\n    });\n\n    async.series(operations, function (err, results) {\n        var issues = [];\n\n        if (err && !options.all) {\n            logger.error(logger.getErrorMessage(err));\n        }\n\n        results[0].items.forEach(function (result) {\n            if (result) {\n                issues = issues.concat(result);\n            }\n        });\n\n        issues.sort(function (a, b) {\n            return a.number > b.number ? -1 : 1;\n        });\n\n        if (issues && issues.length > 0) {\n            issues.forEach(function (issue) {\n                var labels = issue.label || [];\n\n                logger.log(logger.colors.green('#' + issue.number) + ' ' + issue.title + ' ' +\n                    logger.colors.magenta('@' + issue.user.login + ' (' + logger.getDuration(issue.created_at) + ')'));\n\n                if (options.detailed) {\n                    if (issue.body) {\n                        logger.log(issue.body);\n                    }\n\n                    labels.forEach(function (label) {\n                        labels.push(label.name);\n                    });\n\n                    if (labels.length > 0) {\n                        logger.log(logger.colors.green('label: ') + labels.join(', '));\n                    }\n\n                    if (issue.milestone) {\n                        logger.log(logger.colors.green('milestone: ') +\n                            issue.milestone.title + ' - ' + issue.milestone.number);\n                    }\n\n                    logger.log(logger.colors.blue(issue.html_url));\n                }\n            });\n            opt_callback && opt_callback(err);\n        }\n    });\n};\n\nexports.Impl = Issue;\n","/home/travis/build/npmtest/node-npmtest-gh/node_modules/gh/lib/cmds/milestone.js":"/*\n * Copyright 2013-2015, All Rights Reserved.\n *\n * Code licensed under the BSD License:\n * https://github.com/node-gh/gh/blob/master/LICENSE.md\n *\n * @author Zeno Rocha <zno.rocha@gmail.com>\n * @author Eduardo Lundgren <edu@rdo.io>\n */\n\n'use strict';\n\n// -- Requires -------------------------------------------------------------------------------------\n\nvar async = require('async'),\n    base = require('../base'),\n    logger = require('../logger');\n\n// -- Constructor ----------------------------------------------------------------------------------\n\nfunction Milestone(options) {\n    this.options = options;\n\n    if (options.organization) {\n        options.all = true;\n    }\n\n    if (!options.repo && !options.all) {\n        logger.error('You must specify a Git repository with a GitHub remote to run this command');\n    }\n}\n\n// -- Constants ------------------------------------------------------------------------------------\n\nMilestone.DETAILS = {\n    alias: 'ms',\n    description: 'Provides a set of util commands to work with Milestones.',\n    iterative: 'number',\n    commands: [\n        'list',\n    ],\n    options: {\n        'all': Boolean,\n        'organization': String,\n        'list': Boolean,\n    },\n    shorthands: {\n        'a': ['--all'],\n        'o': ['--organization'],\n        'l': ['--list'],\n    },\n    payload: function (payload, options) {\n        options.list = true;\n    }\n};\n\n// -- Commands -------------------------------------------------------------------------------------\n\nMilestone.prototype.run = function () {\n    var instance = this,\n        options = instance.options;\n\n    if (options.list) {\n        if (options.all) {\n            logger.log('Listing milestones for ' +\n                logger.colors.green(options.organization || options.user));\n\n            instance.listFromAllRepositories(function (err) {\n                if (err) {\n                    logger.error('Can\\'t list milestones for ' + options.user + '.');\n                    return;\n                }\n            });\n        }\n        else {\n            logger.log('Listing milestones on ' + logger.colors.green(options.user + '/' + options.repo));\n\n            instance.list(options.user, options.repo, function (err) {\n                if (err) {\n                    logger.error('Can\\'t list milestones on ' + options.user + '/' + options.repo);\n                    return;\n                }\n            });\n        }\n    }\n};\n\nMilestone.prototype.list = function (user, repo, opt_callback) {\n    var instance = this,\n        options = instance.options,\n        payload;\n\n    payload = {\n        repo: repo,\n        user: user\n    };\n\n    base.github.issues.getAllMilestones(payload, function (err, milestones) {\n        if (err && !options.all) {\n            logger.error(logger.getErrorMessage(err));\n        }\n\n        milestones.sort(function (a, b) {\n            return a.due_date > b.due_date ? -1 : 1;\n        });\n\n        if (milestones && milestones.length > 0) {\n            milestones.forEach(function (milestone) {\n                var due = milestone.due_on ? logger.getDuration(milestone.due_on) : 'n/a';\n                var description = milestone.description || '';\n                var prefix = '';\n\n                if (options.all) {\n                    prefix = logger.colors.blue(user + '/' + repo + ' ');\n                }\n\n                logger.log(prefix +\n                    logger.colors.green(milestone.title) + ' ' + (description + ' ').trim() +\n                    logger.colors.magenta('@' + milestone.state + ' (due ' + due + ')'));\n            });\n        }\n\n        opt_callback && opt_callback(err);\n    });\n};\n\nMilestone.prototype.listFromAllRepositories = function (opt_callback) {\n    var instance = this,\n        options = instance.options,\n        operations = [],\n        op = 'getAll',\n        payload;\n\n    payload = {\n        type: 'all',\n        user: options.user\n    };\n\n    if (options.organization) {\n        op = 'getFromOrg';\n        payload.org = options.organization;\n    }\n\n    base.github.repos[op](payload, function (err, repositories) {\n        if (err) {\n            opt_callback && opt_callback(err);\n        }\n        else {\n            repositories.forEach(function (repository) {\n                operations.push(function (callback) {\n                    instance.list(repository.owner.login, repository.name, callback);\n                });\n            });\n        }\n\n        async.series(operations, opt_callback);\n    });\n};\n\nexports.Impl = Milestone;\n","/home/travis/build/npmtest/node-npmtest-gh/node_modules/gh/lib/cmds/notification.js":"/*\n * Copyright 2013-2015, All Rights Reserved.\n *\n * Code licensed under the BSD License:\n * https://github.com/node-gh/gh/blob/master/LICENSE.md\n *\n * @author Zeno Rocha <zno.rocha@gmail.com>\n * @author Eduardo Lundgren <edu@rdo.io>\n */\n\n'use strict';\n\n// -- Requires -------------------------------------------------------------------------------------\n\nvar async = require('async'),\n    base = require('../base'),\n    logger = require('../logger'),\n    printed = {};\n\n// -- Constructor ----------------------------------------------------------------------------------\n\nfunction Notifications(options) {\n    this.options = options;\n\n    if (!options.repo) {\n        logger.error('You must specify a Git repository with a GitHub remote to run this command');\n    }\n}\n\n// -- Constants ------------------------------------------------------------------------------------\n\nNotifications.DETAILS = {\n    alias: 'nt',\n    description: 'Provides a set of util commands to work with Notifications.',\n    commands: [\n        'latest',\n        'watch'\n    ],\n    options: {\n        'latest': Boolean,\n        'remote': String,\n        'repo': String,\n        'user': String,\n        'watch': Boolean\n    },\n    shorthands: {\n        'l': ['--latest'],\n        'r': ['--repo'],\n        'u': ['--user'],\n        'w': ['--watch']\n    },\n    payload: function (payload, options) {\n        options.latest = true;\n    }\n};\n\n// -- Commands -------------------------------------------------------------------------------------\n\nNotifications.prototype.run = function () {\n    var instance = this,\n        options = instance.options;\n\n    if (options.latest) {\n        logger.log('Listing activities on ' + logger.colors.green(options.user + '/' + options.repo));\n        instance.latest();\n    }\n\n    if (options.watch) {\n        logger.log('Watching any activity on ' + logger.colors.green(options.user + '/' + options.repo));\n        instance.watch();\n    }\n};\n\nNotifications.prototype.latest = function (opt_watch) {\n    var instance = this,\n        options = instance.options,\n        operations,\n        payload,\n        listEvents,\n        filteredListEvents = [];\n\n    operations = [\n\n        function (callback) {\n            payload = {\n                user: options.user,\n                repo: options.repo\n            };\n\n            base.github.events.getFromRepo(payload, function (err, data) {\n                if (!err) {\n                    listEvents = data;\n                }\n                callback(err);\n            });\n        },\n        function (callback) {\n            listEvents.forEach(function (event) {\n                event.txt = instance.getMessage_(event);\n\n                if (opt_watch) {\n                    if (!printed[event.created_at]) {\n                        filteredListEvents.push(event);\n                    }\n                }\n                else {\n                    filteredListEvents.push(event);\n                }\n\n                printed[event.created_at] = true;\n            });\n            callback();\n        }\n    ];\n\n    async.series(operations, function (err) {\n        if (err) {\n            logger.error('Can\\'t get latest notifications.');\n            return;\n        }\n\n        if (filteredListEvents.length) {\n            if (!options.watch) {\n                logger.log(logger.colors.yellow(options.user + '/' + options.repo));\n            }\n\n            filteredListEvents.forEach(function (event) {\n                logger.log(logger.colors.magenta('@' + event.actor.login) + ' ' +\n                    event.txt + ' ' + logger.colors.cyan(options.repo) + ' ' +\n                    logger.getDuration(event.created_at));\n            });\n        }\n    });\n};\n\nNotifications.prototype.watch = function () {\n    var instance = this,\n        intervalTime = 3000;\n\n    instance.latest();\n\n    setInterval(function () {\n        instance.latest(true);\n    }, intervalTime);\n};\n\nNotifications.prototype.getMessage_ = function (event) {\n    var txt = '',\n        type = event.type,\n        payload = event.payload;\n\n    switch (type) {\n        case 'CommitCommentEvent':\n            txt = 'commented on a commit at';\n            break;\n        case 'CreateEvent':\n            txt = 'created ' + payload.ref_type + ' ' + logger.colors.green(payload.ref) + ' at';\n            break;\n        case 'DeleteEvent':\n            txt = 'removed ' + payload.ref_type + ' ' + logger.colors.green(payload.ref) + ' at';\n            break;\n        case 'ForkEvent':\n            txt = 'forked';\n            break;\n        case 'GollumEvent':\n            txt = payload.pages[0].action + ' the ' + logger.colors.green(payload.pages[0].page_name) + ' wiki page at';\n            break;\n        case 'IssueCommentEvent':\n            txt = 'commented on issue ' + logger.colors.green('#' + payload.issue.number) + ' at';\n            break;\n        case 'IssuesEvent':\n            txt = payload.action + ' issue ' + logger.colors.green('#' + payload.issue.number) + ' at';\n            break;\n        case 'MemberEvent':\n            txt = 'added ' + logger.colors.green('@' + payload.member.login) + ' as a collaborator to';\n            break;\n        case 'PageBuildEvent':\n            txt = 'builded a GitHub Page at';\n            break;\n        case 'PublicEvent':\n            txt = 'open sourced';\n            break;\n        case 'PullRequestEvent':\n            txt = payload.action + ' pull request ' + logger.colors.green('#' + payload.number) + ' at';\n            break;\n        case 'PullRequestReviewCommentEvent':\n            txt = 'commented on pull request ' + logger.colors.green('#' + payload.pull_request.number) + ' at';\n            break;\n        case 'PushEvent':\n            txt = 'pushed ' + logger.colors.green(payload.size) + ' commit(s) to';\n            break;\n        case 'ReleaseEvent':\n            txt = 'released ' + logger.colors.green(payload.release.tag_name) + ' at';\n            break;\n        case 'StatusEvent':\n            txt = 'changed the status of a commit at';\n            break;\n        case 'WatchEvent':\n            txt = 'starred';\n            break;\n        default:\n            logger.error('event type not found: ' + logger.colors.red(type));\n            break;\n    }\n\n    return txt;\n};\n\nexports.Impl = Notifications;\n","/home/travis/build/npmtest/node-npmtest-gh/node_modules/gh/lib/cmds/pull-request.js":"/*\n * Copyright 2013-2015, All Rights Reserved.\n *\n * Code licensed under the BSD License:\n * https://github.com/node-gh/gh/blob/master/LICENSE.md\n *\n * @author Eduardo Lundgren <edu@rdo.io>\n * @author Zeno Rocha <zno.rocha@gmail.com>\n */\n\n'use strict';\n\n// -- Requires -------------------------------------------------------------------------------------\n\nvar async = require('async'),\n    base = require('../base'),\n    git = require('../git'),\n    hooks = require('../hooks'),\n    logger = require('../logger'),\n    openUrl = require('open'),\n    Issues = require('./issue').Impl,\n    config = base.getConfig();\n\n// -- Constructor ----------------------------------------------------------------------------------\n\nfunction PullRequest(options) {\n    this.options = options;\n\n    if (!options.repo && !options.all) {\n        logger.error('You must specify a Git repository with a GitHub remote to run this command');\n    }\n\n    this.issue = new Issues(options);\n}\n\n// -- Constants ------------------------------------------------------------------------------------\n\nPullRequest.DETAILS = {\n    alias: 'pr',\n    description: 'Provides a set of util commands to work with Pull Requests.',\n    iterative: 'number',\n    commands: [\n        'browser',\n        'close',\n        'comment',\n        'fetch',\n        'fwd',\n        'info',\n        'list',\n        'merge',\n        'open',\n        'rebase',\n        'submit'\n    ],\n    options: {\n        'all': Boolean,\n        'branch': String,\n        'browser': Boolean,\n        'close': Boolean,\n        'comment': String,\n        'description': String,\n        'detailed': Boolean,\n        'direction': String,\n        'fetch': Boolean,\n        'fwd': String,\n        'issue': Number,\n        'info': Boolean,\n        'list': Boolean,\n        'me': Boolean,\n        'merge': Boolean,\n        'number': [String, Array],\n        'open': Boolean,\n        'org': String,\n        'rebase': Boolean,\n        'remote': String,\n        'repo': String,\n        'sort': String,\n        'state': ['open', 'closed'],\n        'submit': String,\n        'title': String,\n        'user': String\n    },\n    shorthands: {\n        'a': ['--all'],\n        'b': ['--branch'],\n        'B': ['--browser'],\n        'C': ['--close'],\n        'c': ['--comment'],\n        'D': ['--description'],\n        'd': ['--detailed'],\n        'f': ['--fetch'],\n        'i': ['--issue'],\n        'I': ['--info'],\n        'l': ['--list'],\n        'M': ['--merge'],\n        'm': ['--me'],\n        'n': ['--number'],\n        'o': ['--open'],\n        'O': ['--org'],\n        'R': ['--rebase'],\n        'r': ['--repo'],\n        'S': ['--state'],\n        's': ['--submit'],\n        't': ['--title'],\n        'u': ['--user']\n    },\n    payload: function (payload, options) {\n        if (payload[0]) {\n            options.fetch = true;\n        }\n        else {\n            options.list = true;\n        }\n    }\n};\n\nPullRequest.DIRECTION_DESC = 'desc';\nPullRequest.DIRECTION_ASC = 'asc';\nPullRequest.FETCH_TYPE_CHECKOUT = 'checkout';\nPullRequest.FETCH_TYPE_MERGE = 'merge';\nPullRequest.FETCH_TYPE_REBASE = 'rebase';\nPullRequest.FETCH_TYPE_SILENT = 'silent';\nPullRequest.SORT_CREATED = 'created';\nPullRequest.SORT_COMPLEXITY = 'complexity';\nPullRequest.STATE_CLOSED = 'closed';\nPullRequest.STATE_OPEN = 'open';\n\n// -- Commands -------------------------------------------------------------------------------------\n\nPullRequest.prototype.options = null;\n\nPullRequest.prototype.issues = null;\n\nPullRequest.prototype.run = function () {\n    var instance = this,\n        options = instance.options;\n\n    instance.config = config;\n\n    options.number = options.number || instance.getPullRequestNumberFromBranch_();\n    options.pullBranch = instance.getBranchNameFromPullNumber_(options.number);\n    options.state = options.state || PullRequest.STATE_OPEN;\n\n    if (!options.pullBranch && (options.close || options.fetch || options.merge)) {\n        logger.error('You\\'ve invoked a method that requires an issue number.');\n    }\n\n    if (options.browser) {\n        instance.browser(options.user, options.repo, options.number);\n    }\n\n    if (!options.list) {\n        options.branch = options.branch || config.default_branch;\n    }\n\n    if (options.close) {\n        instance._closeHandler();\n    }\n\n    if (options.comment) {\n        instance._commentHandler();\n    }\n\n    if (options.fetch) {\n        instance._fetchHandler();\n    }\n    else if (options.merge || options.rebase) {\n        instance._mergeHandler();\n    }\n\n    if (options.fwd === '') {\n        options.fwd = config.default_pr_forwarder;\n    }\n\n    if (options.fwd) {\n        this._fwdHandler();\n    }\n\n    if (options.info) {\n        this._infoHandler();\n    }\n\n    if (options.list) {\n        this._listHandler();\n    }\n\n    if (options.open) {\n        this._openHandler();\n    }\n\n    if (options.submit === '') {\n        options.submit = config.default_pr_reviewer;\n    }\n\n    if (options.submit) {\n        this._submitHandler();\n    }\n};\n\nPullRequest.prototype.addComplexityParamToPulls_ = function (pulls, opt_callback) {\n    var instance = this,\n        metrics,\n        operations,\n        options = instance.options;\n\n    operations = pulls.map(function (pull) {\n        return function (callback) {\n            options.number = pull.number;\n            instance.getPullRequest_(function (err, pull2) {\n                if (!err) {\n                    metrics = {\n                        additions: pull2.additions,\n                        changedFiles: pull2.changed_files,\n                        comments: pull2.comments,\n                        deletions: pull2.deletions,\n                        reviewComments: pull2.review_comments\n                    };\n                    pull.complexity = instance.calculateComplexity_(metrics);\n                }\n                callback(err, pull);\n            });\n        };\n    });\n\n    async.series(operations, function (err, results) {\n        opt_callback(err, results);\n    });\n};\n\nPullRequest.prototype.browser = function (user, repo, number) {\n    openUrl(config.github_host + user + '/' + repo + '/pull/' + number);\n};\n\nPullRequest.prototype.calculateComplexity_ = function (metrics) {\n    var complexity,\n        weightAddition = 2,\n        weightChangedFile = 2,\n        weightComment = 2,\n        weightDeletion = 2,\n        weightReviewComment = 1;\n\n    complexity = (metrics.additions * weightAddition) +\n        (metrics.changedFiles * weightChangedFile) +\n        (metrics.comments * weightComment) +\n        (metrics.deletions * weightDeletion) +\n        (metrics.reviewComments * weightReviewComment);\n\n    return complexity;\n};\n\nPullRequest.prototype.close = function (opt_callback) {\n    var instance = this,\n        options = instance.options,\n        operations,\n        pull;\n\n    operations = [\n\n        function (callback) {\n            instance.getPullRequest_(function (err, data) {\n                if (!err) {\n                    pull = data;\n                }\n                callback(err);\n            });\n        },\n        function (callback) {\n            instance.updatePullRequest_(\n                pull.title, pull.body, PullRequest.STATE_CLOSED, callback);\n        },\n        function (callback) {\n            if (options.pullBranch === options.currentBranch) {\n                git.checkout(pull.base.ref);\n            }\n\n            if (options.pullBranch) {\n                git.deleteBranch(options.pullBranch);\n            }\n\n            callback();\n        }\n    ];\n\n    async.series(operations, function (err) {\n        opt_callback && opt_callback(err, pull);\n    });\n};\n\nPullRequest.prototype.checkPullRequestIntegrity_ = function (originalError, user, opt_callback) {\n    var instance = this,\n        options = instance.options,\n        payload,\n        pull;\n\n    payload = {\n        user: user,\n        repo: options.repo,\n        state: PullRequest.STATE_OPEN\n    };\n\n    base.github.pullRequests.getAll(payload, function (err, pulls) {\n        if (!err) {\n            pulls.forEach(function (data) {\n                if ((data.base.ref === options.branch) &&\n                    (data.head.ref === options.currentBranch) &&\n                    (data.base.sha === data.head.sha) &&\n                    (data.base.user.login === user) &&\n                    (data.head.user.login === options.user)) {\n\n                    pull = data;\n                    originalError = null;\n                    return;\n                }\n            });\n        }\n\n        opt_callback && opt_callback(originalError, pull);\n    });\n};\n\nPullRequest.prototype.fetch = function (opt_type, opt_callback) {\n    var instance = this,\n        options = instance.options,\n        headBranch,\n        repoUrl;\n\n    instance.getPullRequest_(function (err, pull) {\n        if (err) {\n            opt_callback && opt_callback(err);\n            return;\n        }\n\n        headBranch = pull.head.ref;\n        repoUrl = pull.head.repo.ssh_url;\n\n        git.fetch(repoUrl, headBranch, options.pullBranch);\n\n        if (opt_type !== PullRequest.FETCH_TYPE_SILENT) {\n            git[opt_type](options.pullBranch);\n        }\n\n        opt_callback(err, pull);\n    });\n};\n\nPullRequest.prototype.filterPullsSentByMe_ = function (pulls) {\n    var instance = this,\n        options = instance.options;\n\n    pulls = pulls.filter(function (pull) {\n        if (options.loggedUser === pull.user.login) {\n            return pull;\n        }\n    });\n\n    return pulls;\n};\n\nPullRequest.prototype.forward = function (opt_callback) {\n    var instance = this,\n        options = instance.options,\n        operations,\n        submittedPull,\n        pull;\n\n    operations = [\n\n        function (callback) {\n            instance.fetch(PullRequest.FETCH_TYPE_SILENT, function (err, data) {\n                pull = data;\n                callback(err);\n            });\n        },\n        function (callback) {\n            options.title = pull.title;\n            options.description = pull.body;\n            options.submittedUser = pull.user.login;\n\n            instance.submit(options.fwd, function (err, data) {\n                if (err) {\n                    callback(err);\n                    return;\n                }\n\n                options.submittedPullNumber = data.number;\n\n                submittedPull = data;\n                callback();\n            });\n        }\n    ];\n\n    async.series(operations, function (err) {\n        opt_callback && opt_callback(err, submittedPull);\n    });\n};\n\nPullRequest.prototype.getPullRequest_ = function (opt_callback) {\n    var instance = this,\n        options = instance.options,\n        payload;\n\n    payload = {\n        number: options.number,\n        repo: options.repo,\n        user: options.user\n    };\n\n    base.github.pullRequests.get(payload, opt_callback);\n};\n\nPullRequest.prototype.getBranchNameFromPullNumber_ = function (number) {\n    if (number) {\n        return config.pull_branch_name_prefix + number;\n    }\n};\n\nPullRequest.prototype.getPullRequestNumberFromBranch_ = function () {\n    var instance = this,\n        options = instance.options,\n        prefix;\n\n    prefix = config.pull_branch_name_prefix;\n\n    if (options.currentBranch && options.currentBranch.indexOf(prefix) > -1) {\n        return options.currentBranch.replace(prefix, '');\n    }\n};\n\nPullRequest.prototype.getPullsTemplateJson_ = function (pulls, opt_callback) {\n    var instance = this,\n        options = instance.options,\n        branch,\n        branches,\n        json;\n\n    branches = {};\n    json = {\n        branches: []\n    };\n\n    pulls.forEach(function (pull) {\n        branch = pull.base.ref;\n\n        if (!options.branch || options.branch === branch) {\n            branches[branch] = branches[branch] || [];\n            branches[branch].push(pull);\n        }\n    });\n\n    Object.keys(branches).forEach(function (branch) {\n        json.branches.push({\n            name: branch,\n            pulls: branches[branch],\n            total: branches[branch].length\n        });\n    });\n\n    opt_callback && opt_callback(null, json);\n};\n\nPullRequest.prototype.printPullInfo_ = function (pull) {\n    var options = this.options;\n\n    logger.log(logger.colors.green('#' + pull.number) + ' ' +\n        pull.title + ' ' + logger.colors.magenta('@' + pull.user.login) +\n        ' (' + logger.getDuration(pull.created_at) + ')');\n\n    if (options.detailed) {\n        logger.log(logger.colors.blue(pull.html_url));\n    }\n\n    if (pull.mergeable_state === 'clean') {\n        logger.log(logger.colors.green('Mergeable (' + pull.mergeable_state + ')'));\n    }\n    else if (pull.mergeable_state !== undefined) {\n        logger.warn(logger.colors.red('Not mergeable (' + pull.mergeable_state + ')'));\n    }\n\n    if ((options.info || options.detailed) && pull.body) {\n        logger.log(pull.body + '\\n');\n    }\n};\n\nPullRequest.prototype.get = function (user, repo, number) {\n    var pr = this,\n        payload;\n\n    payload = {\n        repo: repo,\n        user: user,\n        number: number\n    };\n\n    base.github.pullRequests.get(payload, function (err, pull) {\n        if (err) {\n            logger.warn('Can\\'t get pull request ' + user + '/' + repo + '/' + number);\n            return;\n        }\n\n        pr.printPullInfo_(pull);\n    });\n};\n\nPullRequest.prototype.list = function (user, repo, opt_callback) {\n    var instance = this,\n        options = instance.options,\n        json,\n        operations,\n        payload,\n        pulls,\n        sort;\n\n    sort = options.sort;\n\n    if (options.sort === PullRequest.SORT_COMPLEXITY) {\n        sort = PullRequest.SORT_CREATED;\n    }\n\n    payload = {\n        direction: options.direction,\n        repo: repo,\n        sort: sort,\n        state: options.state,\n        user: user\n    };\n\n    operations = [\n\n        function (callback) {\n            base.github.pullRequests.getAll(payload, function (err, data) {\n                pulls = [];\n\n                if (!err) {\n                    if (options.me) {\n                        pulls = instance.filterPullsSentByMe_(data);\n                    }\n                    else {\n                        pulls = data;\n                    }\n                }\n\n                if (err && err.code === 404) {\n                    // some times a repo is found, but you can't listen its prs\n                    // due to the repo being disabled (e.g., private repo with debt)\n                    logger.warn('Can\\'t list pull requests for ' + user + '/' + payload.repo);\n                    callback();\n                }\n                else {\n                    callback(err);\n                }\n            });\n        },\n\n        function (callback) {\n            if (options.sort && options.sort === PullRequest.SORT_COMPLEXITY) {\n                instance.addComplexityParamToPulls_(pulls, function (err, data) {\n                    if (!err) {\n                        pulls = instance.sortPullsByComplexity_(data);\n                    }\n\n                    callback(err);\n                });\n            }\n            else {\n                callback();\n            }\n        },\n\n        function (callback) {\n            instance.getPullsTemplateJson_(pulls, function (err, data) {\n                if (!err) {\n                    json = data;\n                }\n                callback(err);\n            });\n        }\n    ];\n\n    async.series(operations, function (err) {\n        if (!err && pulls.length) {\n            logger.log(logger.colors.yellow(user + '/' + repo));\n\n            json.branches.forEach(function (branch) {\n                logger.log(branch.name + ' (' + branch.total + ')');\n\n                branch.pulls.forEach(instance.printPullInfo_, instance);\n            });\n        }\n\n        opt_callback && opt_callback(err);\n    });\n};\n\nPullRequest.prototype.listFromAllRepositories = function (opt_callback) {\n    var instance = this,\n        options = instance.options,\n        payload,\n        apiMethod;\n\n    payload = {\n        type: 'all',\n        user: options.user,\n        per_page: 1000\n    };\n\n    if(options.org) {\n        apiMethod = 'getFromOrg';\n        payload.org = options.org;\n    } else {\n        apiMethod = 'getAll';\n    }\n\n    base.github.repos[apiMethod](payload, function (err, repositories) {\n        if (err) {\n            opt_callback && opt_callback(err);\n        }\n        else {\n            repositories.forEach(function (repository) {\n                instance.list(repository.owner.login, repository.name, opt_callback);\n            });\n        }\n    });\n};\n\nPullRequest.prototype.listFromAllOrgRepositories = function (opt_callback) {\n    var instance = this,\n        options = instance.options,\n        payload;\n\n    payload = {\n        type: 'all',\n        user: options.user,\n        org: options.org,\n        per_page: 1000\n    };\n\n    base.github.repos.getFromOrg(payload, function (err, repositories) {\n        if (err) {\n            opt_callback && opt_callback(err);\n        }\n        else {\n            repositories.forEach(function (repository) {\n                instance.list(repository.owner.login, repository.name, opt_callback);\n            });\n        }\n    });\n};\n\nPullRequest.prototype.merge = function (opt_callback) {\n    var instance = this,\n        options = instance.options,\n        method = 'merge';\n\n    if (options.rebase) {\n        method = 'rebase';\n    }\n\n    git.checkout(options.branch);\n    git[method](options.pullBranch);\n    git.push(config.default_remote, options.branch);\n    git.deleteBranch(options.pullBranch);\n    opt_callback && opt_callback();\n};\n\nPullRequest.prototype.open = function (opt_callback) {\n    var instance = this;\n\n    instance.getPullRequest_(function (err, pull) {\n        if (err) {\n            opt_callback && opt_callback(err);\n        }\n        else {\n            instance.updatePullRequest_(\n                pull.title, pull.body, PullRequest.STATE_OPEN, opt_callback);\n        }\n    });\n};\n\nPullRequest.prototype.setMergeCommentRequiredOptions_ = function (opt_callback) {\n    var options = this.options,\n        lastCommitSHA = git.getLastCommitSHA(),\n        changes = git.countUserAdjacentCommits();\n\n    options.currentSHA = lastCommitSHA;\n\n    if (changes > 0) {\n        options.changes = changes;\n    }\n\n    options.pullHeadSHA = lastCommitSHA + '~' + changes;\n\n    opt_callback && opt_callback();\n};\n\nPullRequest.prototype.sortPullsByComplexity_ = function (data) {\n    var instance = this,\n        options = instance.options;\n\n    data.sort(function (a, b) {\n        if (a.complexity > b.complexity) {\n            return -1;\n        }\n        else if (a.complexity < b.complexity) {\n            return +1;\n        }\n        else {\n            return 0;\n        }\n    });\n\n    if (options.direction === PullRequest.DIRECTION_ASC) {\n        data.reverse();\n    }\n\n    return data;\n};\n\nPullRequest.prototype.submit = function (user, opt_callback) {\n    var instance = this,\n        options = instance.options,\n        operations,\n        pullBranch;\n\n    pullBranch = options.pullBranch || options.currentBranch;\n\n    operations = [\n\n        function (callback) {\n            git.push(config.default_remote, pullBranch);\n            callback();\n        },\n        function (callback) {\n            if (!options.title) {\n                options.title = git.getLastCommitMessage(pullBranch);\n            }\n\n            callback();\n        },\n        function (callback) {\n            var payload = {\n                base: options.branch,\n                head: options.user + ':' + pullBranch,\n                repo: options.repo,\n                user: user\n            };\n\n            if (options.issue) {\n                payload.issue = options.issue;\n                base.github.pullRequests.createFromIssue(payload, callback);\n            }\n            else {\n                payload.body = options.description;\n                payload.title = options.title;\n                base.github.pullRequests.create(payload, callback);\n            }\n        }\n    ];\n\n    async.series(operations, function (err, results) {\n        if (err) {\n            instance.checkPullRequestIntegrity_(err, user, opt_callback);\n        }\n        else {\n            opt_callback && opt_callback(err, results[2]);\n        }\n    });\n};\n\nPullRequest.prototype.updatePullRequest_ = function (title, opt_body, state, opt_callback) {\n    var instance = this,\n        options = instance.options,\n        payload;\n\n    if (opt_body) {\n        opt_body = logger.applyReplacements(opt_body, config.replace);\n    }\n\n    payload = {\n        body: opt_body,\n        number: options.number,\n        repo: options.repo,\n        state: state,\n        title: title,\n        user: options.user\n    };\n\n    base.github.pullRequests.update(payload, opt_callback);\n};\n\nPullRequest.prototype._fetchHandler = function () {\n    var instance = this,\n        options = this.options,\n        fetchType = PullRequest.FETCH_TYPE_CHECKOUT;\n\n    if (options.merge) {\n        fetchType = PullRequest.FETCH_TYPE_MERGE;\n    }\n    else if (options.rebase) {\n        fetchType = PullRequest.FETCH_TYPE_REBASE;\n    }\n\n    hooks.invoke('pull-request.fetch', instance, function (afterHooksCallback) {\n        var operation = '',\n            branch = options.pullBranch;\n\n        if (options.merge) {\n            operation = ' and merging';\n            branch = options.currentBranch;\n        }\n\n        if (options.rebase) {\n            operation = ' and rebasing';\n            branch = options.currentBranch;\n        }\n\n        logger.log('Fetching pull request ' +\n            logger.colors.green('#' + options.number) + operation +\n            ' into branch ' + logger.colors.green(branch));\n\n        instance.fetch(fetchType, function (err) {\n            if (err) {\n                logger.error('Can\\'t fetch pull request ' + options.number + '.');\n                return;\n            }\n\n            afterHooksCallback();\n        });\n    });\n};\n\nPullRequest.prototype._mergeHandler = function () {\n    var instance = this,\n        options = this.options,\n        operation = 'Merging';\n\n    hooks.invoke('pull-request.merge', instance, function (afterHooksCallback) {\n        if (options.rebase) {\n            operation = 'Rebasing';\n        }\n\n        logger.log(operation + ' pull request ' + logger.colors.green('#' + options.number) +\n            ' into branch ' + logger.colors.green(options.branch));\n\n        instance.merge();\n        instance.setMergeCommentRequiredOptions_(afterHooksCallback);\n    });\n};\n\nPullRequest.prototype._fwdHandler = function () {\n    var instance = this,\n        options = this.options;\n\n    hooks.invoke('pull-request.fwd', instance, function (afterHooksCallback) {\n        logger.log('Forwarding pull request ' +\n            logger.colors.green('#' + options.number) + ' to ' + logger.colors.magenta('@' + options.fwd));\n\n        instance.forward(function (err, pull) {\n            if (err) {\n                logger.error('Can\\'t forward pull request ' + options.number + ' to ' + options.fwd + '.');\n                return;\n            }\n\n            if (pull) {\n                options.forwardedPull = pull.number;\n            }\n\n            logger.log(pull.html_url);\n            instance.setMergeCommentRequiredOptions_(afterHooksCallback);\n        });\n    });\n};\n\nPullRequest.prototype._closeHandler = function () {\n    var instance = this,\n        options = this.options;\n\n    hooks.invoke('pull-request.close', instance, function (afterHooksCallback) {\n        logger.log('Closing pull request ' + logger.colors.green('#' + options.number));\n\n        instance.close(function (err, pull) {\n            if (err) {\n                logger.warn('Can\\'t close pull request ' + options.number + '.');\n                return;\n            }\n\n            logger.log(pull.html_url);\n\n            instance.setMergeCommentRequiredOptions_(afterHooksCallback);\n        });\n    });\n};\n\nPullRequest.prototype._commentHandler = function () {\n    var options = this.options;\n\n    logger.log('Adding comment on pull request ' + logger.colors.green('#' + options.number));\n\n    this.issue.comment(function (err, pull) {\n        if (err) {\n            logger.error('Can\\'t comment on pull request ' + options.number + '.');\n            return;\n        }\n\n        logger.log(pull.html_url);\n    });\n};\n\nPullRequest.prototype._infoHandler = function () {\n    var instance = this,\n        options = this.options;\n\n    instance.get(options.user, options.repo, options.number, function (err) {\n        if (err) {\n            logger.error('Can\\'t get pull requests.');\n            return;\n        }\n    });\n};\n\nPullRequest.prototype._listHandler = function () {\n    var instance = this,\n        options = this.options,\n        who;\n\n    options.sort = options.sort || PullRequest.SORT_CREATED;\n    options.direction = options.direction || PullRequest.DIRECTION_DESC;\n\n    if (options.all) {\n        who = options.user;\n\n        if (options.org) {\n            who = options.org;\n        }\n\n        logger.log('Listing all ' + options.state + ' pull requests for ' + logger.colors.green(who));\n\n        instance.listFromAllRepositories(function (err) {\n            if (err) {\n                logger.error('Can\\'t list all pull requests from repos.');\n                return;\n            }\n        });\n    }\n    else {\n        if (options.me) {\n            logger.log('Listing ' + options.state + ' pull requests sent by ' +\n                logger.colors.green(options.loggedUser) + ' on ' +\n                logger.colors.green(options.user + '/' + options.repo));\n        }\n        else {\n            logger.log('Listing ' + options.state + ' pull requests on ' +\n                logger.colors.green(options.user + '/' + options.repo));\n        }\n        instance.list(options.user, options.repo, function (err) {\n            if (err) {\n                logger.error('Can\\'t list pull requests.');\n                return;\n            }\n        });\n    }\n};\n\nPullRequest.prototype._openHandler = function () {\n    var instance = this,\n        options = this.options;\n\n    hooks.invoke('pull-request.open', instance, function (afterHooksCallback) {\n        logger.log('Opening pull request ' + logger.colors.green('#' + options.number));\n\n        instance.open(function (err, pull) {\n            if (err) {\n                logger.error('Can\\'t open pull request ' + options.number + '.');\n                return;\n            }\n\n            logger.log(pull.html_url);\n            afterHooksCallback();\n        });\n    });\n};\n\nPullRequest.prototype._submitHandler = function () {\n    var instance = this,\n        options = this.options;\n\n    hooks.invoke('pull-request.submit', instance, function (afterHooksCallback) {\n        logger.log('Submitting pull request to ' + logger.colors.magenta('@' + options.submit));\n\n        instance.submit(options.submit, function (err, pull) {\n            if (err) {\n                try {\n                    logger.error('Can\\'t submit pull request. ' + JSON.parse(err.message).errors[0].message);\n                } catch (ignore) {\n                    console.error(err);\n                }\n                return;\n            }\n\n            if (pull) {\n                options.submittedPull = pull.number;\n            }\n\n            logger.log(pull.html_url);\n            instance.setMergeCommentRequiredOptions_(afterHooksCallback);\n        });\n    });\n};\n\nexports.Impl = PullRequest;\n","/home/travis/build/npmtest/node-npmtest-gh/node_modules/gh/lib/cmds/repo.js":"/*\n * Copyright 2013-2015, All Rights Reserved.\n *\n * Code licensed under the BSD License:\n * https://github.com/node-gh/gh/blob/master/LICENSE.md\n *\n * @author Henrique Vicente <henriquevicente@gmail.com>\n * @author Eduardo Lundgren <eduardo.lundgren@gmail.com>\n * @author Zeno Rocha <zno.rocha@gmail.com>\n */\n\n'use strict';\n\n// -- Requires -------------------------------------------------------------------------------------\n\nvar base = require('../base'),\n    git = require('../git'),\n    hooks = require('../hooks'),\n    logger = require('../logger'),\n    openUrl = require('open'),\n    inquirer = require('inquirer'),\n    url = require('url'),\n    config = base.getConfig();\n\n// -- Constructor ----------------------------------------------------------------------------------\n\nfunction Repo(options) {\n    this.options = options;\n}\n\n// -- Constants ------------------------------------------------------------------------------------\n\nRepo.DETAILS = {\n    alias: 're',\n    description: 'Provides a set of util commands to work with Repositories.',\n    commands: [\n        'browser',\n        'clone',\n        'delete',\n        'fork',\n        'list',\n        'new'\n    ],\n    options: {\n        'browser': Boolean,\n        'clone': Boolean,\n        'delete': String,\n        'description': String,\n        'detailed': Boolean,\n        'gitignore': String,\n        'fork': String,\n        'homepage': String,\n        'init': Boolean,\n        'list': Boolean,\n        'new': String,\n        'organization': String,\n        'private': Boolean,\n        'repo': String,\n        'type': ['all', 'forks', 'member', 'owner', 'public', 'private', 'sources'],\n        'user': String\n    },\n    shorthands: {\n        'B': ['--browser'],\n        'c': ['--clone'],\n        'D': ['--delete'],\n        'd': ['--detailed'],\n        'f': ['--fork'],\n        'l': ['--list'],\n        'N': ['--new'],\n        'O': ['--organization'],\n        'p': ['--private'],\n        'r': ['--repo'],\n        't': ['--type'],\n        'u': ['--user']\n    },\n    payload: function (payload, options) {\n        if (options.browser !== false) {\n            options.browser = true;\n        }\n    }\n};\n\nRepo.TYPE_ALL = 'all';\nRepo.TYPE_FORKS = 'forks';\nRepo.TYPE_MEMBER = 'member';\nRepo.TYPE_OWNER = 'owner';\nRepo.TYPE_PRIVATE = 'private';\nRepo.TYPE_PUBLIC = 'public';\nRepo.TYPE_SOURCES = 'sources';\n\n// -- Commands -------------------------------------------------------------------------------------\n\nRepo.prototype.run = function () {\n    var instance = this,\n        options = instance.options,\n        user = options.loggedUser;\n\n    instance.config = config;\n\n    if (options.browser) {\n        instance.browser(options.user, options.repo);\n    }\n\n    if (options.delete) {\n        hooks.invoke('repo.delete', instance, function (afterHooksCallback) {\n            logger.log('Deleting repo ' + logger.colors.green(options.user + '/' + options.delete));\n\n            inquirer.prompt(\n                [\n                    {\n                        type: 'input',\n                        message: 'Are you sure? This action CANNOT be undone. [y/N]',\n                        name: 'confirmation'\n                    }\n                ], function (answers) {\n                    if (answers.confirmation.toLowerCase() === 'y') {\n                        instance.delete(options.user, options.delete, function (err) {\n                            if (err) {\n                                logger.error('Can\\'t delete repo.');\n                                return;\n                            }\n\n                            afterHooksCallback();\n                        });\n                    }\n                    else {\n                        logger.log('Not deleted.');\n                    }\n                });\n        });\n    }\n\n    if (options.fork) {\n        hooks.invoke('repo.fork', instance, function (afterHooksCallback) {\n            if (options.organization) {\n                user = options.organization;\n            }\n\n            options.repo = options.fork;\n\n            logger.log('Forking repo ' + logger.colors.green(options.user + '/' + options.repo) +\n                ' on ' + logger.colors.green(user + '/' + options.repo));\n\n            instance.fork(function (err1, repo) {\n                if (err1) {\n                    logger.error('Can\\'t fork. ' + JSON.parse(err1).message);\n                    return;\n                }\n\n                logger.log(repo.html_url);\n\n                if (repo && options.clone) {\n                    instance.clone_(options.loggedUser, options.repo, repo.ssh_url);\n                }\n\n                afterHooksCallback();\n            });\n        });\n    }\n\n    if (options.list) {\n        if (options.organization) {\n            user = options.organization;\n            options.type = options.type || Repo.TYPE_ALL;\n        } else {\n            user = options.user;\n            options.type = options.type || Repo.TYPE_OWNER;\n        }\n\n        if (options.isTTY.out) {\n            logger.log('Listing ' + logger.colors.green(options.type) + ' repos for ' +\n                logger.colors.green(user));\n        }\n\n\n        instance.list(user, function (err) {\n            if (err) {\n                logger.error('Can\\'t list repos.');\n            }\n        });\n    }\n\n    if (options.new) {\n        hooks.invoke('repo.new', instance, function (afterHooksCallback) {\n            options.repo = options.new;\n\n            if (options.organization) {\n                options.user = options.organization;\n            }\n\n            logger.log('Creating a new repo on ' + logger.colors.green(options.user + '/' + options.new));\n\n            instance.new(function (err1, repo) {\n                if (err1) {\n                    logger.error('Can\\'t create new repo. ' + JSON.parse(err1.message).message);\n                    return;\n                }\n\n                logger.log(repo.html_url);\n\n                if (repo && options.clone) {\n                    instance.clone_(options.user, options.repo, repo.ssh_url);\n                }\n\n                afterHooksCallback();\n            });\n        });\n    }\n};\n\nRepo.prototype.browser = function (user, repo) {\n    openUrl(config.github_host + user + '/' + repo);\n};\n\nRepo.prototype.clone_ = function (user, repo, repo_url) {\n    logger.log('Cloning ' + logger.colors.green(user + '/' + repo));\n    git.clone(url.parse(repo_url).href, repo);\n};\n\nRepo.prototype.delete = function (user, repo, opt_callback) {\n    var payload;\n\n    payload = {\n        user: user,\n        repo: repo\n    };\n\n    base.github.repos.delete(payload, opt_callback);\n};\n\nRepo.prototype.list = function (user, opt_callback) {\n    var instance = this,\n        method = 'getFromUser',\n        options = instance.options,\n        payload;\n\n    payload = {\n        type: options.type,\n        user: user,\n        per_page: 1000\n    };\n\n    if (options.organization) {\n        method = 'getFromOrg';\n        payload.org = options.organization;\n    }\n\n    if (options.type === 'public' || options.type === 'private') {\n        if (user === options.user) {\n            method = 'getAll';\n        }\n        else {\n            logger.error('You can only list your own public and private repos.');\n            return;\n        }\n    }\n\n    base.github.repos[method](payload, function (err, repos) {\n        instance.listCallback_(err, repos, opt_callback);\n    });\n};\n\nRepo.prototype.listCallback_ = function (err, repos, opt_callback) {\n    var instance = this,\n        options = instance.options,\n        pos,\n        repo;\n\n    if (err && !options.all) {\n        logger.error(logger.getErrorMessage(err));\n    }\n\n    if (repos && repos.length > 0) {\n        for (pos in repos) {\n            if (repos.hasOwnProperty(pos) && repos[pos].full_name) {\n                repo = repos[pos];\n                logger.log(repo.full_name);\n\n                if (options.detailed) {\n                    logger.log(logger.colors.blue(repo.html_url));\n\n                    if (repo.description) {\n                        logger.log(logger.colors.blue(repo.description));\n                    }\n\n                    if (repo.homepage) {\n                        logger.log(logger.colors.blue(repo.homepage));\n                    }\n\n                    logger.log('last update ' + logger.getDuration(repo.updated_at));\n                }\n\n                if (options.isTTY.out) {\n                    logger.log(logger.colors.green('forks: ' + repo.forks +\n                            ', stars: ' + repo.watchers + ', issues: ' + repo.open_issues) + '\\n');\n                }\n            }\n        }\n\n        opt_callback && opt_callback(err);\n    }\n};\n\nRepo.prototype.fork = function (opt_callback) {\n    var instance = this,\n        options = instance.options,\n        payload;\n\n    payload = {\n        user: options.user,\n        repo: options.repo\n    };\n\n    if (options.organization) {\n        payload.organization = options.organization;\n    }\n\n    base.github.repos.fork(payload, opt_callback);\n};\n\nRepo.prototype.new = function (opt_callback) {\n    var instance = this,\n        options = instance.options,\n        payload,\n        method = 'create';\n\n    options.description = options.description || '';\n    options.gitignore = options.gitignore || '';\n    options.homepage = options.homepage || '';\n    options.init = options.init || false;\n\n    if (options.type === Repo.TYPE_PRIVATE) {\n        options.private = true;\n    }\n\n    options.private = options.private || false;\n\n    if (options.gitignore) {\n        options.init = true;\n    }\n\n    payload = {\n        auto_init: options.init,\n        description: options.description,\n        gitignore_template: options.gitignore,\n        homepage: options.homepage,\n        name: options.new,\n        private: options.private\n    };\n\n    if (options.organization) {\n        method = 'createFromOrg';\n        payload.org = options.organization;\n    }\n\n    base.github.repos[method](payload, opt_callback);\n};\n\nexports.Impl = Repo;\n","/home/travis/build/npmtest/node-npmtest-gh/node_modules/gh/lib/cmds/track.js":"/*\n * Copyright 2013-2015, All Rights Reserved.\n *\n * Code licensed under the BSD License:\n * https://github.com/node-gh/gh/blob/master/LICENSE.md\n *\n */\n\n'use strict';\n\n// -- Requires -------------------------------------------------------------------------------------\n\nvar logger = require('../logger'),\n    tracker = require('../tracker');\n\n// -- Constructor ----------------------------------------------------------------------------------\n\nfunction Track(options) {\n    this.options = options;\n}\n\n// -- Constants ------------------------------------------------------------------------------------\n\nTrack.DETAILS = {\n    alias: 'tk',\n    description: 'Anonymous usage reporting control.',\n    commands: [\n        'opt-in',\n        'opt-out'\n    ],\n    options: {\n        'opt-in': Boolean,\n        'opt-out': Boolean\n    },\n    shorthands: {\n        'o': ['--opt-in'],\n        'O': ['--opt-out']\n    }\n};\n\n// -- Commands -------------------------------------------------------------------------------------\n\nTrack.prototype.run = function () {\n    var options = this.options;\n\n    if (options['opt-in']) {\n        this.optIn();\n    }\n\n    if (options['opt-out']) {\n        this.optOut();\n    }\n\n    this.isTracking();\n};\n\nTrack.prototype.isTracking = function () {\n    var status = 'enable',\n        next = 'opt-out',\n        current = tracker.optOut !== false;\n\n    if (current) {\n        status = 'disable';\n        next = 'opt-in';\n    }\n\n    logger.log('Reporting anonymous usage statistics is ' + logger.bold.bold(status + 'd') + '.');\n    logger.log('You can ' + next + ' it with: ' + logger.bold.cyan('gh track --' + next));\n};\n\nTrack.prototype.optIn = function () {\n    tracker.optOut = false;\n};\n\nTrack.prototype.optOut = function () {\n    tracker.optOut = true;\n};\n\nexports.Impl = Track;\n","/home/travis/build/npmtest/node-npmtest-gh/node_modules/gh/lib/cmds/version.js":"/*\n * Copyright 2013-2015, All Rights Reserved.\n *\n * Code licensed under the BSD License:\n * https://github.com/node-gh/gh/blob/master/LICENSE.md\n *\n * @author Henrique Vicente <henriquevicente@gmail.com>\n */\n\n'use strict';\n\nvar base = require('../base'),\n    logger = require('../logger');\n\nfunction Version() {\n}\n\nVersion.DETAILS = {\n    alias: 'v',\n    description: 'Print gh version.'\n};\n\nVersion.prototype.run = function () {\n    base.asyncReadPackages(this.printVersion);\n};\n\nVersion.prototype.printVersion = function (pkg) {\n    logger.log(pkg.name + ' ' + pkg.version);\n};\n\nexports.Impl = Version;\n"}